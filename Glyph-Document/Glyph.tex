%xelatex
\documentclass[12pt,a4paper]{article}
%%%%%%%%%%%%%%%%%%%%%
%% \usepackage[]{Tex/ordinal}
%% \usepackage{fontspec}
%% \setmainfont{texgyrepagella}[
%%   Extension = .otf,
%%   UprightFont = *-regular,
%%   BoldFont = *-bold,
%%   ItalicFont = *-italic,
%%   BoldItalicFont = *-bolditalic,
%% ]
%% \usepackage{unicode-math}
%% \setmathfont{STIXTwoMath-Regular.otf}
%%%%%%%%%%%%%%%%%%%%%
\usepackage{xspace}
\def\Glyph{\textbf{Glyph}\xspace}
\def\Skia{\textbf{Skia}\xspace}
%%%%%%%%%%%%%%%%%%%%%
\usepackage{scalalistings}
\usepackage{verbatimstyle}
\usepackage{pdffig}
\usepackage{manyfoot}

\def\glyph[#1]#2{
\begin{center}
\marginpar{\textsf{\scriptsize{\\[16ex]Glyph\\#2}}}
\penalty-2000\pdffig[#1]{PNG/cap-#2}\\
\end{center}
}

\def\cglyph[#1]#2{
\begin{center}
%\marginpar{\textsf{\scriptsize{\\[16ex]Glyph\\#2}}}
\penalty-2000\pdffig[#1]{PNG/cap-#2}\\
\end{center}
}



\def\smallglyph[#1]#2{
\bgroup
\footnotesize
\penalty-1000\textsf{Glyph #2}\\[1ex]
\penalty-1000\pdffig[#1]{PNG/cap-#2}\\
\egroup
}

\def\sample[#1]#2{
\begin{center}
\penalty-1000\pdffig[#1]{PNG/cap-#2}
\end{center}
}

\def\PNGfig[#1]#2{
%\penalty-1000
\pdffig[#1]{PNG/#2}
}

\def\samples[#1]#2#3{
\begin{center}
\pdffig[#1]{PNG/cap-#2}\quad\quad\quad
\pdffig[#1]{PNG/cap-#3}
\end{center}
}

\def\SAVEDFIGURE#1#2{
\begin{figure}[h]
\begin{center}
\pdffig[scale=0.36]{SAVED/#1}
\caption{#2}
\label{#1}
\end{center}
\end{figure}
}


\def\SAVEDFIG#1/#2/{\SAVEDFIGURE{#1}{#2}}

\def\Scala#1{\textcolor{blue}{\textsf{#1}}}

\let\scalasize=\footnotesize
\let\scalainlinesize=\small
\def\scalafamily{\sffamily}
\verbatimfamily{\sffamily}

\parindent=0pt
\parskip=\medskipamount


%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{sectsty}
\usepackage{titlesec}
\usepackage{color}
\usepackage[bookmarks,hypertexnames=false,debug,linktocpage=true,hidelinks]{hyperref}

\hypersetup{
    colorlinks,
    linktoc=all,
    linkcolor={blue},
    citecolor={blue},
    urlcolor={blue}
}

%%%%%%%%%%%%%%%%%%%%%
\def\S#1{\section{#1}}
\def\SS#1{\subsection{#1}}
\def\SSS#1{\subsubsection*{#1}}

%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
\author{Bernard Sufrin\thanks{Emeritus Fellow: Department of Computer
Science \& Worcester College, Oxford; Tutor in Computer Science,
Magdalen College, Oxford}}
\title{The \Glyph User-Interface Library}
\date{Draft of \today}
%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\maketitle
\begin{abstract}

In this note we introduce the \Glyph user-interface library for Scala.  Its
graphical features are geometrically compositional:  rendered using
a small subset of the facilities of  Google's \Skia{\footnote{\Skia
is a highly portable 2-D graphics library used in the implementation of several
browsers, including Chrome.}}, as delivered (in the JVM) by the \textbf{Skija}
library.\footnote{The present prototype
runs on Linux, Windows, OS/X (both x86 and Apple Mx processors)}

Our motivation for developing the library was our frustration, over many years,
with complex UI frameworks that impose a uniform style, and that make
it hard to develop novel modes of interaction.\footnote{There is
nothing wrong with uniform styling: it's the cost of straying outside
the styling envelope that we want to diminish. An interface designer
who doesn't mind learning a new language (Dart) and staying within its
envelope might be rewarded by investigating Google's
\href{https://api.flutter.dev/index.html}{Flutter}: a comprehensive kit
for building app(lication)s for a large variety of devices
and operating systems.} 

The belief that has guided this work is that a rich set of interactive
interface components can be composed using a small collection of combining
forms, together with a suitable collection of elementary visual
components -- some reactive.
So instead of (just) providing a uniformly-styled ``high level''
toolkit, we have provided enough elements and combining forms for
an innovative UI designer to experiment with, and a collection of
implementations of conventional components (for example buttons,
checkboxes, text input components, notebooks) to serve as models.
\vfill
\end{abstract}
\clearpage
\tableofcontents
\clearpage
\listoffigures
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%


\S{User Interfaces with Glyph}
\SS{Introduction}

A complete \Glyph user interface (GUI) is specified as a tree of
\SCALA{Glyph} components, that may be \textit{passive}, \textit{active},
or \textit{reactive}.  Composite nodes of the tree consist of
collections of components that share the same bounding box -- being
juxtaposed geometrically or temporally within it.

For example, suppose \SCALA{a}'s bounding box is 5 units wide and 3
units high; and that of \SCALA{b} is the same width and 1 unit height
-- perhaps as painted\footnote{A glyph's colour and visual texture
is specified by its foregound and background: both determined
by properties of the \SCALA{Brush}es used to paint it.} respectively yellow and green) by:

\begin{scala}
  def a = FilledRect(5*units, 3*units, fg=yellow)
  def b = FilledRect(5*units, 1*units, fg=green)
\end{scala}
then
\begin{scala}
                Row(Col(a, b), Col(a, b))
\end{scala}
has a bounding box that is the horizontal catenation of 2 copies
of the bounding box of \SCALA{Col(a, b)}; the latter has a bounding
box that is the vertical catenation of the bounding boxes of \SCALA{a},
\SCALA{b}. The outcome will be drawn as:\footnote{We have added thin frames around
$a$ and $b$ to show their extents within the bounding box.}


\begin{center}
\pdffig[scale=0.6]{PNG/eg1a}
\end{center}

The height of a row is the maximum height of its components; its width is
the sum of its components' widths; and a row is normally drawn with its
components aligned along its top edge.

So exchanging \SCALA{Col} and \SCALA{Row}
in the above leads to:
\begin{center}
\PNGfig[scale=0.6]{eg1b}
\end{center}
The glyph trees for the two images are:
\begin{scala}
           Row                     Col
           +--Col                  +--Row 
           |  +--  a               |  +--a
           |  +--  b               |  +--b
           +--Col                  +--Row 
              +-- a                   +--a
              +-- b                   +--b
\end{scala}


We will later show other ways of composing glyphs.

\SS{Reactive Glyphs and Focus}

Reactive glyphs are the means by which user actions, such as mouse
gestures and keystrokes, are coupled to the semantic actions of the
application they control. As usual these actions can 
result in changes to the appearance of the interface.

Unless it is just a passive image in a window, one or more of the
nodes in the glyph tree of a GUI will be a \SCALA{ReactiveGlyph}
-- designed to respond to specific user actions such as gesturing
at a window with mouse or trackpad, or typing a keystroke.

Interaction with the GUI in a window is mediated by its associated
\SCALA{Interaction} component, whose primary role is to determine
which reactive glyph a user's action or a system-reported event is
to be directed at, and to direct it there. To this end 
with each window is associated a \Scala{keyboardFocus}, and a
\Scala{mouseFocus}  variable -- both of type
\Scala{Option[ReactiveGlyph]}. These are managed by the
\Scala{EventHandler} module of its associated \Scala{Interaction},
which implements the \textit{Focus Protocol} described
in detail in Appendix \ref{thefocusprotocol}.

\begin{comment}
\footnote{A window's \Scala{RootGlyph}
also manages the ancillary glyph trees associated with the implementation
of dialogues, menus, and transient decorations. The management of ancillaries
lends an element of complexity to the protocol implementation, but
a detailed discussion is not needed here.}

\footnote{\textit{via} the standard
reactive \Scala{RootGlyph} component that contains every
GUI tree as its single branch.} 
\end{comment}

\SSS{Mouse Focus}
Normally, a mouse event (mouse motion, mouse button press or release)
is directed at the reactive glyph that has the mouse focus -- this
is almost always the reactive glyph within whose bounding box the mouse
cursor is shown. When the mouse cursor strays outside the currently
mouse-focussed glyph a \Scala{GlyphLeave} event is directed
at the glyph, and we say that the mouse focus is 
\textit{uncommitted}.  The mouse focus
stays uncommitted until the cursor moves into a(nother) reactive glyph.
The focus is now committed to this glyph, which is informed of it
by being sent a \Scala{GlyphEnter} event.

\SSS{Keyboard Focus}
A reactive glyph, such as  one that is going to respond to typing,
will normally ``grab'' the keyboard focus when it receives a
\Scala{GlyphEnter} event, and \textit{may} give it up when it
receives a \Scala{GlyphLeave} event.\footnote{We write \textit{may}
because some glyphs do not require the mouse to be inside them in
order to respond to the keyboard.} Any reactive component can acquire
or be given the keyboard focus at any time; and can give it up or give
it away at any time.\footnote{Perhaps surprisingly, keyboard-focus-gained and keyboard-focus-lost events
have not, so far been needed.}

Normally a keyboard event is directed at the reactive glyph that
has the keyboard focus; when there is no such glyph, then it is
first directed at the glyph that previously held the keyboard focus;
and if there is no such glyph then the ``orphan'' event is (usually)
ignored.\footnote{We write \textit{usually} because there is
additional provision for catching and acting upon unfocussed keyboard
events that can in principle be used to give some sort of feedback.}



%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\S{Glyphs}
\SS{The Glyph Interface}

The unit of graphical composition is the \SCALA{Glyph}. All implemented \SCALA{Glyph}s:

\begin{enumerate}
        \item Define how they are to be ``painted'' on a
        \SCALA{Surface}\footnote{A Surface
        implements the primitive methods that are used to paint
        shapes.}
        
        Painting instructions always use a \textit{local co-ordinate space}
        with origin at $(0,0)$. 

        \item Define the \SCALA{Brush}es to be
        used when they are painted: usually by specifying foreground and
        background brushes.

        \item Define the diagonal of the rectangular bounding box they
        will occupy on the surface.

        \item Define the location of the top left corner of the
        abovementioned bounding box relative to the origin of the
        bounding box of their parent in the glyph-tree. This is
        usually determined when the parent glyph is laid out; and
        happens for the first time during the composition
        of the parent.

        \item Define a method that yields a \textit{structurally identical} copy
        of the glyph: perhaps one that uses different brushes.     
\end{enumerate}

A purely passive graphical glyph may be elementary (simple), or composite. 
Simple glyphs are constructed by \textit{Glyph factories},
many of which require no more than a specification of the
diagonal of the bounding box of the graphic: its foreground and background
brushes can be specified explicitly or by default.
%
The actual location of a glyph when painted on its surface is usually
defined by its location relative to its parent in the glyph tree.

Although a glyph type is usually \textit{defined} by a Scala class,
our API convention is that instances used in application GUIs are
almost invariably \textit{constructed} by one of the methods of the
Scala companion object of its class. For example

\begin{scala}
 FilledRect(w: Scalar, h: Scalar,    fg: Brush=..., bg: Brush=...)
 Rect(w: Scalar, h: Scalar,          fg: Brush=..., bg: Brush=...)
 FilledOval(w: Scalar, h: Scalar,    fg: Brush=..., bg: Brush=...)
 Label(text: String, font: Font = ...fg: Brush=..., bg: Brush=...)
 Polygon(w: Scalar, h: Scalar,
         fg: Brush=..., bg: Brush=...)(points: ...)
\end{scala}




\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%



\SS{Glyph Composition}

Composite glyphs are specialised instances of the \SCALA{Composite}
extension of \SCALA{Glyph}, and are also usually constructed by
\textit{Glyph factories}. These include:

\begin{scala}

        Row             Col
        Concentric      OneOf
\end{scala}

The \SCALA{Row} and \SCALA{Col} compositions are (almost)
explainable by their names. Each has variants that
explain the exact way in which components are aligned. Here
are the \SCALA{Row.atTop(...)} \SCALA{Row.centered(...)} \SCALA{Row.atBottom(...)}
compositions of a pair of rectangles:\footnote{\Scala{Row}, and \Scala{Row.atTop}
mean the same.}
\begin{center}

\pdffig[scale=0.5]{PNG/row-t}
\quad\quad
\pdffig[scale=0.5]{PNG/row-c}
\quad\quad
\pdffig[scale=0.5]{PNG/row-b}
\end{center}

Here
are the \SCALA{Col.atLeft(...)} \SCALA{Col.centered(...)} \SCALA{Col.atRight(...)}
compositions of a different pair:\footnote{\Scala{Col}, and
\Scala{Col.atLeft} mean the same.}
\begin{center}

\pdffig[scale=0.5]{PNG/col-l}
\quad\quad
\pdffig[scale=0.5]{PNG/col-c}
\quad\quad
\pdffig[scale=0.5]{PNG/col-r}
\end{center}

The row and column compositions described above yield glyphs that
are ``naturally'' sized. Thus, for example, a row's width is the
sum of its components' widths, and its height is the maximum of its
components' heights. There are also fixed-size row (and column)
compositions, whose row width and column height can be declared in advance,
and that allow ``expandable'' spaces as components. Here we see a couple of examples:\footnote{\Scala{tab} is
an expandable space.}

\begin{center}
\pdffig[scale=0.45]{PNG/row-fixed}
\quad\quad
\pdffig[scale=0.45]{PNG/row-fixed-j}
\end{center}

These were constructed by:
\begin{scala}
import FixedSize.Space.tab
FixedSize.Row(350f, bg=grey)(tab, redR, blueR, redR)
FixedSize.Row(350f, bg=grey)(redR, tab, blueR, tab, redR)
\end{scala}
with
\begin{scala}
def redR:  Glyph = FilledRect(50f, 25f, fg=red)
def blueR: Glyph = FilledRect(100f, 25, fg=blue)
\end{scala}

Finally, here are the \SCALA{Concentric.centered(...)},
\SCALA{Concentric.atTop(...)} and \\d\SCALA{Concentric.atRight(...)}
compositions of a point and a pair of rectangles:\footnote{\Scala{Concentric}, and
\Scala{Concentric.centered} mean the same;
and there are (of course) \Scala{atLeft} and \Scala{atBottom} variants
of \Scala{Concentric}.}


\begin{center}
\pdffig[scale=0.5]{PNG/conc}
\quad\quad
\pdffig[scale=0.5]{PNG/conc-t}
\quad\quad
\pdffig[scale=0.5]{PNG/conc-r} 
\end{center}

\SSS{Temporal Alternations of Glyphs}
The \SCALA{OneOf} composition is used primarily in the implementation of
dynamically ``paged'' interfaces. It constructs a glyph whose appearance is chosen
dynamically from a palette of component glyphs.
Its bounding box is the union of the bounding boxes of its component glyphs;
and it shows only one of them at a time, namely the one selected most recently by  its \SCALA{select} method,
or by one of its \SCALA{next()} or \SCALA{prev()} methods.

Thus the definitions\footnote{See ``Glyphs are mutable'' (\ref {glyphsaremutable}) for an explanation
of why the label is defined as a function not just as a value.}
\begin{scala}
  def bananas = Label("Bananas", fg=white, bg=blue)
  val oneof: OneOf =
      OneOf(bg = Wide.red)( bananas.rotated(0)
                          , bananas.rotated(1)
                          , bananas.rotated(2)
                          , bananas.rotated(3)
                          )
 \end{scala}
gives rise to the glyph that is initially drawn as:
\begin{center}
\pdffig[scale=0.6]{PNG/oneof}
\end{center}

and after the execution of \SCALA{oneof.next()} is drawn as:
\begin{center}
\pdffig[scale=0.6]{PNG/oneofnext}
\end{center}

Subsequent invocations of \Scala{oneof.next()} will select successive components
for drawing, and an invocation of \Scala{oneof.select(n)} will select its $n$th (modulo 4)
component for drawing.\footnote{Only the currently selected component of a
\Scala{OneOf} is considered in the search for a reactive glyph to handle
a user gesture or keystroke. See Appendix \ref{thefocusprotocol} for details.} 

Had \SCALA{oneof} been specified without a background brush, then
the background would have been one of the backgrounds of its
maximal (by area) components.
\begin{center}
\pdffig[scale=0.6]{PNG/oneofnbg}
\end{center}



\SS{Brushes}
A brush applies ``paint'' to a surface. The
most important of its characteristics are its width (aka \SCALA{strokeWidth}), and
the colour of the paint it will apply. But it also has ``shape'', in the sense that
corners painted with it may be rounded, squared, mitered,
\textit{etc}; as well as having many other definable
characteristics, including a human-readable name.

For example, here are definitions of the \SCALA{blue} and \SCALA{red} brushes.\footnote{Colour
is specified here by a 32-bit/4-byte integer -- usually written as a hexadecimal
constant. The first byte specifies its
\textit{alpha} -- which is analogous to opacity or covering power; the second, third, and fourth bytes
specify its red, green, and blue components.} 
\begin{scala}
  val blue = Brush("blue")(color=0xFF0000ff,  width=1.0f, cap=ROUND)
  val red  = Brush("red") (color=0xFFFF0000,  width=1.0f, cap=ROUND)
\end{scala}

and \SCALA{val Wide.blue} was defined as:
\begin{scala}
  Brush("Wide.blue")(color = 0xFF0000ff,
                     width = 15.0f,
                     cap   = SQUARE)
\end{scala}

\pagebreak[4]
The following two images show some brush properties in action. Notice the
rounded corners of the first rectangle, and that the points have
all the characteristics of the brushes they were drawn with.

\glyph[scale=0.6]{eg1d}

\glyph[scale=0.6]{eg1e}


In fact the library incorporates an embedded domain-specific language of brushes:
some expressions denote new brushes or variants of existing
brushes; and others denote commands that affect existing
brushes.\footnote{See appendix \ref{brushesaremutable} for an explanation
and examples of the latter.}
%
For example, the \SCALA{Wide.blue} brush could  have been defined
as a variant of \SCALA{blue}:

\begin{scala}

               blue(width=15.0f, name="Wide.Blue", cap=SQUARE)
\end{scala}

Brushes are  cheap to build, and it is straightforward to
define them \textit{ad-hoc} while building a glyph.\footnote{Implementation
details of the brush language may be of interest to the Scala
programmer who likes the idea of ``notationally sugared'' APIs.}

For example:
\begin{scala}
Row.centered(
   Point(Wide.blue(width=2*Wide.blue.strokeWidth, cap=BUTT)),
   Skip(2*Wide.blue.strokeWidth),
   Rect(150f, 100f, Brush("")(color=red.color,
                              width=Wide.blue.strokeWidth, cap=SQUARE)))
\end{scala}

denotes the glyph
\begin{center}
\PNGfig[scale=0.6]{eg1ex}
\end{center}




\newpage
\S{Glyph Transformers}

Glyph transformers are used to derive glyphs from simpler glyphs. For example:

\glyph[scale=0.6]{eg1f}

\glyph[scale=0.6]{eg1g}

It's important to understand that, as a matter of policy, transforming a glyph, $g$
is an ``algebraic'' operation that results in a tree in which $g$ is
embedded: it no more makes  a new copy of it than
(for example) the successor $succ~n$ of a number $n$ makes a new copy of
$n$.\footnote{In light of the first prototype library implementing
glyphs mutably there is an argument against this policy because it
could lead to inadvertent sharing, with effects such as those
described in Appendix \ref{glyphsaremutable}. A future prototype is envisaged
in which glyphs are no longer mutable, and the policy will
be irrelevant.}


\begin{comment}
\begin{center}
\PNGfig[scale=0.6]{static}

\PNGfig[scale=0.6]{staticdown}
\end{center}
\end{comment}

Most of these ``extrinsic'' transformers are also delivered as
``intrinsic'' methods of glyphs. At the time of writing the intrinsic
transformers are:

\begin{scala}
  def scaled(scale: Scale): Glyph 
  def enlarged(delta: Scalar, ...): Glyph 
  def enlargedTo(w: Scalar, h: Scalar, ...): Glyph 
  def enlargedBy(w: Scalar, h: Scalar, ...): Glyph 
  def rotated(quadrants: Int, ...): Glyph 
  def turned(degrees: Scalar, circular: Boolean, ...): Glyph 
  def skewed(skewX: Scalar, skewY: Scalar, ...): Glyph =
  def mirrored(leftRight: Boolean, topBottom: Boolean, ...): Glyph =
  def framed(fg: Brush = Glyphs.Framed.defaultFG,
             bg: Brush = Glyphs.Framed.defaultBG): Glyph
  def edged(fg: Brush = Glyphs.Framed.defaultFG,
            bg: Brush = Glyphs.Framed.defaultBG): Glyph
  def shaded(...
             enlarge: Scalar = 0.25f,
             delta: Scalar = 8f,
             down: Boolean=false): Glyph =      
\end{scala}

In the above signatures, the abbreviation \SCALA{...} stands for the declaration that `fg` and `bg` parameters be inherited from
``this'' Glyph unless otherwise specified. For example, the full signature of \SCALA{mirrored} is:
\begin{scala}

  def mirrored(leftRight: Boolean, topBottom: Boolean,
               fg: Brush = thisGlyph.fg,
               bg: Brush = thisGlyph.bg): Glyph    
\end{scala}

Figure \ref{intrinsics} shows a few examples of their use:

\begin{figure}[t]

\PNGfig[scale=0.35]{eg1g}
\hfill
\PNGfig[scale=0.35]{eg1gskew}
\vskip1ex
\SCALA{g} \hfill \SCALA{g.skewed(0.5,0).framed()}
\vskip3ex

\PNGfig[scale=0.35]{eg1gskew2}
\hfill
\PNGfig[scale=0.35]{eg1gskew3}

\SCALA{g.skewed(-0.5, 0).framed()} \hfill \SCALA{g.skewed(-0.5, -0.5).framed()}


\begin{center}
\PNGfig[scale=0.35]{eg1gskew4}
\begin{scala}
g.skewed(0.5f, 0f).enlarged(27, bg=yellow(alpha=0.2f))
                  .framed(redFrame)
                  .turned(45f)
                  .mirrored(leftRight=true,topBottom = false)
                  .framed(fg=redFrame)
\end{scala}
\end{center}

\begin{center}
\PNGfig[scale=0.35]{eg1gskew5}
\SCALA{g.skewed(0.5f, 0.0f).framed().turned(30f).framed(fg=redFrame)}
\end{center}
\caption{Intrinsic glyph transformers in use}
\label{intrinsics}
\end{figure}

\clearpage



%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%



\S{Polygonal Glyphs}

\SS{Specification}
Polygons (open or closed) are specified by giving the coordinates
of the relevant vertices in addition to the diagonal of the bounding
box they will be drawn in.\footnote{A closed polygon is one whose last vertex is the same
as its first.}
They have several forms of constructor: all are features of
\SCALA{Polygon} or \SCALA{FilledPolygon}.
A \textit{rough} guide to deciding on what part of the bounding box
of a filled polygon gets filled is that a point is inside the polygon (therefore filled)
if a line from it to some arbitrarily chosen far away point
crosses one of the lines between adjacent vertices an odd number
of times; it is outside if the number is even.\footnote{The ``far away point'' should be
chosen so that the line is not parallel to one of the edges. This is rarely difficult.}

Compare the two red \SCALA{FilledPolygon}s with vertices respectively given by
\begin{scala}
FilledPolygon(200, 200, fg = red)((0,   0), (200, 200),
                                  (200, 0), (0,   200))

FilledPolygon(200, 200, fg = red)((200, 200), (0, 0),
                                  (200, 0),   (0, 200))
\end{scala}
\samples[scale=0.25]{lineSample3}{lineSample4}

Now compare the two blue \SCALA{FilledPolygon}s with vertices given by
\begin{scala}
FilledPolygon(100, 100, fg = blue)(
  (0,0), (20, 0), (20, 20), (40, 20), (40, 0),
  (60,0), (60, 60), (80, 60), (80, 0), (100,0))
  
FilledPolygon(100, 100, fg = blue)(
 ((100,0), (100, 100), (0, 100), (0,0),
  (20, 0), (20, 20), (40, 20), (40, 0),
  (60,0), (60, 60), (80, 60), (80, 0), (100,0))
\end{scala}
\samples[scale=0.7]{lineSample6}{lineSample7}

\begin{comment}
\pagebreak[3]
The corresponding non-filled \SCALA{Polygon}s are:

\samples[scale=0.8]{lineSample8}{lineSample9}
\end{comment}


%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%

\SS{Paint Effects}
Interesting effects are possible when paints are equipped with
path-effects, or are blurred.

\SSS{Path Effects}
In the following sequence of examples we compute the
vertices of a 7-pointed regular star (a ``stargon''), then construct
a ``wobbly'' paintbrush (\SCALA{blueish}) that is used to render
the star both as a filled polygon and as an open polygon.


First we define generators for filled and non-filled stargon glyphs
of specific colours:

\begin{scala}
 def filledStargon(n: Int, fg: Brush): Glyph =
     FilledPolygon.$(256, 256, fg, nothing)(regularStarPath(n))                        
   
 def nonFilledStargon(n: Int, fg: Brush): Glyph =
     Polygon.$(256, 256, fg, nothing)(regularStarPath(n))                    
\end{scala}


Both use a generator for the vertices of the paths used by
the \SCALA{Polygon} constructors to make star glyphs: $R$ is the
length of edges of the star, with centroid at $(C,C)$.\footnote{Exercise: this
algorithm can be understood by thinking of the points on
the path as the successive places a tortoise will stop when
at each stage it moves by $R$ in the direction $heading$, then turns through
$theta$ -- stopping when it has made $n+1$ moves.
Find out what happens if $n$ is even, explain why, and suggest
an alternative termination condition that yields stargons of \textit{some} order for
$n\ge{}2$. }

\begin{scala}
def regularStarPath(n: Int): Seq[(Scalar, Scalar)] = {
    val C: Scalar = 128.0f
    val R: Scalar = 115f
    val star = new ArrayBuffer[(Scalar, Scalar)]
    val theta = PI - PI/n
    star += (((C + R, C)))
    for {i <- 0 until n} {
      val a = theta * i
      star += (((C + R * Math.cos(a)).toFloat, (C + R * Math.sin(a)).toFloat))
    }
    star += ((C + R, C))
    star.toSeq
  }
\end{scala}

Rendered straightforwardly with \SCALA{fg=blue} the filled and open stargons are:
\begin{center}
\pdffig[scale=0.3]{PNG/filledstar}
\quad\quad
\pdffig[scale=0.3]{PNG/openstar}
\end{center}


 The  \SCALA{blueish: Brush} is the same color as blue, but wider: it has "wobbly" edges specified by its
 \SCALA{pathEffect}.

\begin{scala}
  val blueish =
        blue(width      = blue.strokeWidth*2,
             pathEffect = PathEffect.makeDiscrete(25.0f, 4.0f, 1))
\end{scala}

Rendered in blueish, the stargons are:
\begin{center}
\pdffig[scale=0.3]{PNG/filledstarw}
\quad\quad
\pdffig[scale=0.3]{PNG/openstarw}
\end{center}

All this works for stars of arbitrary odd arity:
here are  stars with $n=17, 11, 5, 3$:

\begin{center}
\pdffig[scale=0.3]{PNG/filledstarw17}
\pdffig[scale=0.3]{PNG/filledstarw11}
\pdffig[scale=0.3]{PNG/filledstarw5}
\pdffig[scale=0.3]{PNG/filledstarw3}
\end{center}

\begin{comment}
But for $n=4, 6, 8$, and other even numbers, the generator doesn't work:
\begin{center}
\pdffig[scale=0.3]{PNG/filledstarw4}
\pdffig[scale=0.3]{PNG/filledstarw6}
\pdffig[scale=0.3]{PNG/filledstarw8}
\end{center}

See if you can explain why the generator doesn't work, by guessing the $n$ used for these two stargons. The
open one uses a brush without a path effect.
\begin{center}
\pdffig[scale=0.3]{PNG/openstarw18}
\pdffig[scale=0.3]{PNG/filledstarw18}
\end{center}
\end{comment}

Using brushes with path effects to draw frames can give aesthetically
interesting results. For example, here is:
\begin{scala}
  Label("Hello!", font(32))
  .enlarged(40)
  .framed(fg=red(width=4f,
                 pathEffect=PathEffect.makeDiscrete(7f, 12.5f, 15),
                 cap=BUTT)))
\end{scala}
\begin{center}
\PNGfig[scale=0.7]{redframed}
\end{center}

The three parameters of \Scala{makeDiscrete} are, in turn, the length of each ``segment'' into which the path
drawn by the paint will be sliced, the limit of displacement of the endpoints of the segment from
the path, and a seed for the generation of random displacements.
It's easier to see the effect of the displacement limit when the path is a straight line. Here's
\begin{scala}
  Polygon(200, 200,
          fg = red(width = 4f,
                   pathEffect = PathEffect.makeDiscrete(5f, 100f, 15),
                   cap = ROUND)
  )((0, 100), (200, 100)).enlarged(4).framed())
\end{scala}

\begin{center}
\PNGfig[scale=0.5]{redpoly}
\end{center}

Many other path effects are available from
\textbf{Skia} \textit{via} \textbf{Skija}.

\clearpage
\SSS{Blurred Paint Effects}
The intrinsic \Scala{Brush}-transformer \Scala{blurred} yields a
brush that blurs all the filled glyphs that it paints. When \Scala{brush: Brush}
\begin{scala}
   brush.blurred(blur: Scalar, dx: Scalar=0f, dy: Scalar=0f): Brush
\end{scala}

yields a blurred brush of the same colour as \Scala{brush}. When
used on \textit{filled} glyphs, it blurs their outline, and
can shift the blurred outline relative to their origin (by $(dx, dy)$.

Below we show the effects of painting a filled star with
\Scala{blue.blurred(24f)} and with \Scala{blue.blurred(48f, 20f, 20f)}.
Both ar \Scala{framed()}: notice that the latter is displaced by $(20, 20)$ within the
natural bounding box indicated by the frame.

\begin{center}
\pdffig[scale=0.5]{PNG/filledstarw5blur}
\quad\quad
\pdffig[scale=0.5]{PNG/filledstarw5blur20}
\end{center}



\SSS{Blurred Frame Effects}
Figure \ref{Etc-Blurred} shows the use of a blurred brush, as
well as uses of the extrinsic glyph transformer

\begin{scala}
   BlurredFrame(blur:Scalar,spread:Scalar,dx:Scalar=0f,dy:Scalar=0f, ...)
\end{scala}

The styled blurred button-framing specification 

\begin{scala}
   Decoration.Blurred(blur:Scalar,spread:Scalar,dx:Scalar=0f,dy:Scalar=0f, ...)
\end{scala}

is illustrated in Figure \ref{Styles-Blurred}.

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix
\S{Mutability of Glyphs and Brushes}
\SS{Glyphs are mutable}\label{glyphsaremutable}
In the present prototype implementation it is \textit{essential to understand that a glyph 
is mutable}: in particular that its \SCALA{location} and \SCALA{parent} features are changed as it is
incorporated in its glyph tree by its parent glyph.

This happens exactly once per glyph, and in order to use a glyph
more than once it necessary to copy it. Fortunately this is
straightforward: each form of glyph has a copy method that yields
a fresh\footnote{\textit{ie.} without having set
\textcolor{blue}{\textsf{location, parent}}.} structurally identical
(``deep'') copy. The copy method has \SCALA{fg, bg} arguments that
specify the foreground and background brushes of the copy; and these
are defaulted to those of the glyph being copied.

As a convenience, the \SCALA{Glyph} may be ``applied'' with the same result:
\begin{scala}
  def copy (fg: Brush=this.fg, bg: Brush=this.bg): Glyph
  def apply(fg: Brush=this.fg, bg: Brush=this.bg): Glyph =
      this.copy(fg, bg)
\end{scala}


When a glyph is used twice without copying, the results are rarely what was intended. For example,
here we show the outcome of using a glyph value a second time in a
tree without copying. When \Scala{egc} is defined by
\begin{scala}
   val egc: Glyph =
            Row.centered(Point(Wide.blue),
                         Skip(Wide.blue.strokeWidth),
                         Point(Wide.green),
                         Rect(150f, 100f, Wide.blue))
\end{scala}
it denotes a glyph drawn as
\begin{center}
\PNGfig[scale=0.55]{egc}
\end{center}
and the expression \Scala{Row(bg=white)(egc, egc)} denotes a glyph
drawn as
\begin{center}
\PNGfig[scale=0.55]{egc2}
\end{center}

What is happening is that \Scala{egc}'s location relative to its
parent in the glyph tree is set twice by the \SCALA{Row} compositor; and the second setting
is the one used during drawing.\footnote{That this can
occur \textit{without warning at compile time} is a defect in the design of the library to which there
are a multiplicity of potential solutions: we are considering them at the time of writing. But
for the moment we advise copying as a matter of course: it's not computationally very expensive.}

When the glyph is copied before both uses all is well:
\Scala{Row(egc(), egc())} is drawn as\footnote{In
fact if it's not going to be used again only one
copy is needed.}
\begin{center}
\PNGfig[scale=0.6]{egc1}
\end{center}


\SS{Brushes are mutable}\label{brushesaremutable}

In the present prototype implementation the attributes of brushes
can be changed dynamically, and the effects of these changes
\textit{apply retrospectively to every glyph that was ever drawn
with them}. Although this feature is not intended to be used frequently, it can occasionally
be useful: for example using a brush on part of a GUI that indicates
state by changing its colour.

Brushes have ``chained'' methods that can be used to change their
attributes; these  have the same names as the attributes, for
example:

\begin{scala}
          def strokeWidth(i: Float):    Brush = { ...; this }
          def color(i: Int):            Brush = { ...; this }       
          def cap(cap: PaintStrokeCap): Brush = { ...; this }
\end{scala}


For example, here's what \SCALA{eg1g} looks like in a context where the colour of the
wide blue \SCALA{Brush} has been changed retrospectively to yellow
by the command:

\begin{scala}
        Wide.blue.color(0xFFFFFF00)
\end{scala}

\begin{center}
\PNGfig[scale=0.6]{eg1gBlueToYellow}
\end{center}
The mutation methods return the glyph from
which they are invoked, so to change colour, width, and cap in the
same command one could write:

\begin{scala}
        Wide.blue.color(0xFFFFFF00).strokeWidth(50).cap(ROUND)
\end{scala}

or, recalling that \textsf{Scala} methods can also be used as infix operators, one could
have written:

\begin{scala}
        Wide.blue color 0xFFFFFF00 strokeWidth 50 cap ROUND
\end{scala}

It is probably unwise to change a stroke width dynamically in such a
way as to increase the size of a bounding box beyond its original
size, for that would invalidate an important assumption made during glyph
composition, namely that the sizes of component glyphs' bounding
boxes do not increase after composition.  This assumption is invalid
for glyphs such as those built by \Scala{.framed(...)} whose
bounding boxes are partly determined by the width of  brushes used
in them. Decreasing a stroke width dynamically does not violate
this assumption.

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%

\S{Text}
Here we discuss the low-level API for generating simple text glyphs. {The \textcolor{blue}{\textsf{Styled}}
package provides more versatile methods for composing glyphs that consist
of paragraphed text.}

A \SCALA{Text} is a glyph-builder, \textit{ie.} a \textit{factory}
for text glyphs. The function \SCALA{text}, defined below, constructs
a glyph-builder from the given string at the specified size in (the
italic Courier) \SCALA{typeFace}.

%\let\scalasize=\footnotesize
\begin{scala}
    val typeFace: Typeface =
          FontMgr.getDefault()
                 .matchFamilyStyle("Courier", FontStyle.ITALIC)

    def text(s: String, size: Float): Text =
          Text(s, new Font(face, size))
\end{scala}

The \SCALA{Text}s \SCALA{text1, text2} are glyph builders that will eventually
yield glyphs. The function \SCALA{em} defines an \textit{em}-width space.

\begin{scala}
    val text1 = text("Á 24pt Text", 24.0f)
    val text2 = text("A 12pt Text", 12.0f)
    def em    = Skip(font(12f).measureTextWidth("m"))
\end{scala}

\SCALA{Text}s provide the following methods that build glyphs:
\begin{scala}
   .asGlyph:    Glyph
   .atBaseline: Glyph
\end{scala}

Both yield glyphs with the same bounding box: but the second yields
a glyph that is expected to be drawn only within top-aligned
\SCALA{Row}'s.

\cglyph[scale=0.6]{text1}
\cglyph[scale=0.6]{text1a}

Drawing a sequence of \SCALA{atBaseline}-generated glyphs in a \textit{top-aligned} row positions them so that their
baselines coincide, and this is the intended effect.
\cglyph[scale=0.6]{textrow1}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
\SSS{Deprecated uses of \SCALA{asGlyph} and \SCALA{atBaseline} glyphs}
Using \SCALA{asGlyph}-generated glyphs of different sizes in rows is a cheap and nasty way
to simulate superscripts and subscripts and is not recommended for normal use.
\cglyph[scale=0.6]{textrow2}
\cglyph[scale=0.6]{textrow3}


When an \SCALA{atBaseline}-generated glyph does not have a \SCALA{Row} as parent, it
is drawn so that its baseline coincides with the top of its bounding rectangle: the result
is \textcolor{red}{never} useful. 
\begin{center}
\SCALA{text1.atBaseline(fg=blue).framed(grey)}

\PNGfig[scale=0.6]{text1b}
\end{center}
Moreover, when \SCALA{atBaseline}-generated glyphs of different heights are used in a bottom- or centre-aligned row the
results are \textcolor{red}{never} useful.
\begin{center}
\begin{scala}
    Row.centered(text1.atBaseline(fg=black),
                 text2.atBaseline(fg=blue)).framed(grey)}
\end{scala}
\PNGfig[scale=0.6]{textrow1a}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\S{The Focus Protocol}
\label{thefocusprotocol}
The windows of an application's GUI each have two foci: each
is either undefined or associated with a reactive glyph.


\begin{itemize}
   \item The  window's \Scala{keyboardFocus} is the reactive glyph that is
   expected to handle keyboard events within that window. Reactive glyphs
   usually co-operate to manage it.

   \item The window's \Scala{mouseFocus} is the reactive glyph that is
   expected to handle mouse events, such as those arising from movements,
   button presses and releases, and from mouse wheel events. Such
   events may also originate on a trackpad, touchscreen, \textit{etc}.
   
\end{itemize}

The (mouse) focus protocol is designed to ensure that events arising from
the manipulation of the mouse (or other pointing device) get directed
to an appropriate reactive glyph. The essence of the protocol is
described below. The specification of ``try to locate a
reactive glyph...'' is at \ref{locatingreactiveglyphs}.

\SS{MouseMove events}
  \begin{itemize}
    \item[(a)] If \Scala{mouseFocus} is defined, then
    \begin{itemize}
        \item[i] If the mouse location is within the focussed glyph, direct the
        event to that glyph.
        \item[ii] If mouse location is not within the focussed glyph, then direct a
        \Scala{GlyphLeave} event to that glyph, and set \Scala{mouseFocus} to \Scala{None}.
    \end{itemize}
    \item[(b)] If \Scala{mouseFocus} is not defined, then try to locate a reactive glyph
               that contains the mouse location.
              \begin{itemize}
                  \item[i] If there is such a reactive glyph, direct a \Scala{GlyphEnter}
                        event to it, and set \Scala{mouseFocus} to it.
                  \item[ii] If there is no such reactive glyph, ignore the event.
              \end{itemize}
  \end{itemize}

  
\SS{MouseButton events}
\begin{itemize}
    \item[(a)] If \Scala{mouseFocus} is defined, then
    \begin{itemize}
        \item[i] If the mouse location is within the focussed glyph, direct the
        event to that glyph.
        \item[ii] If mouse location is not within the focussed glyph, then
        just set \Scala{mouseFocus} to \Scala{None}.
    \end{itemize}
    \item[(b)] If \Scala{mouseFocus} is not defined, then try to locate a reactive glyph
               that contains the mouse location.
              \begin{itemize}
                  \item[i] If there is such a reactive glyph, direct a \Scala{GlyphEnter}
                        event to it, and set \Scala{mouseFocus} to it.
                  \item[ii] If there is no such reactive glyph, ignore the event.
              \end{itemize}
  \end{itemize}


\SS{MouseScroll events}
\begin{itemize}
    \item[(a)] If \Scala{mouseFocus} is defined, then direct the event to the focussed glyph.
    \item[(b)] If \Scala{mouseFocus} is not defined, then ignore the
               event.\footnote{\textbf{We are currently considering
               adding a third locus, namely \Scala{scrollFocus}.}}
\end{itemize}


 


In effect the protocol defined above means that a reactive glyph becomes ``aware'' that it has the focus
when the mouse moves into it; and becomes ``aware'' that it no longer has the focus
when the mouse moves out of it. Although it would be straightforward to change the
protocol so that fewer events are ignored, we believe that in many cases the
response of a glyph to an event ignored in the protocol would be to ... ignore it.


\SS{Locating Reactive Glyphs}\label{locatingreactiveglyphs}
Recall that the glyphs comprising a GUI all have their own
(0,0)-origin coordinate system, and that each glyph is located
relative to its parent in the glyph tree as its parent is being
laid out. This approach makes it straightforward to implement
geometric transforms on glyphs, such as the rotations, scalings, and
skewings described briefly earlier -- a transformed glyph is
displayed by applying the transform before displaying
the untransformed glyph. 

The search for a reactive glyph that contains a location is conducted
by first searching the glyph tree for the glyph
that most closely contains that location, then finding its nearest
reactive parent in the tree (usually, but not always, the same
glyph).

The search for the glyph that most closely contains a location is
conducted top-down in the glyph tree.  Composite glyphs that don't
themselves contain the location are not searched, but those that
do contain the location are searched for more specific components.
For the moment we consider that this algorithm is adequately
efficient, but if necessary glyph trees could be indexed
straightforwardly.


On the other hand, experience has shown that the algorithm
is not efficient enough to use during mouse motion to decide
whether the mouse location is still within the focussed glyph. This is
because mouse motion events are generated at high frequency as the
mouse traverses a window. So instead of using the algorithm, we
annotate each reactive glyph with the inverse of the (constant)
transform that was (last) used to display it, then use this
inverse to map the (absolute) mouse location back to the coordinate
system of the reactive glyph itself.

\SS{Locating  Glyphs in the presence of Overlays}
Menus and dialogues are managed by the module
\Scala{overlaydialogue.Dialogue} which provides a collection
(possibly empty) of \textit{overlays} per window: each of these is specified as a
glyph tree with a few additional properties.

The overlays  are organised as a stack of GUI ``layers''
drawn topmost-last: each appearing  on top of its predecessor in
the stack, and all appearing on top of the main GUI tree.
There is also a collection of named ``decorations'' that , each defined
by a glyph tree. These are drawn in no particular order after the
main GUI and the overlay stack. 

The algorithm to locate a glyph that contains the mouse is designed to find
a currently-visible glyph containing the mouse in:

\begin{enumerate}
\item[i] the topmost layer of the stack, or in
\item[ii] a decoration, or in
\item[iii] a currently-visible glyph in the application's main GUI tree.
\end{enumerate}

When the topmost layer of the stack is ``modal'' (\textit{ie} represents a menu
or a modal dialogue), then only (i) and (ii) above are considered.

The net effect is that glyphs in the main interface
that are \textit{completely hidden} by the topmost layer of the stack will not
be selected during a mouse-focus transfer. Normally, as far as a button
is concerned, if you can't see it \textit{all} then you can't press
it.\footnote{In the exceptional situation of \textit{loose hiding} being
enabled for the topmost overlay then if you can see some of a button then you can press it.}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\S{Anatomy of a Simple Reactive Glyph}

Here we give an account of the structure of the reactive glyph class
\Scala{ColouredButton}. The appearance of such buttons is specified
by a single glyph. The  foreground (or the background) colour of the glyph
changes when the mouse hovers over it, and when a button is
pressed (but not yet released) within it.If its \Scala{background}
flag is true, then it's the background colour of the button that is changed.

It inherits the features of a \Scala{GenericButton} that deal with
the details of mouse-motion and button-clicks. We shall discuss
these later: the main thing to understand now is that the state of
an active, non-disabled button is captured by:

\begin{scala}
    var hovered:  Boolean
    var pressed:  Boolean
\end{scala}

The former is true if and only if the (mouse) pointer is within the
button.\footnote{More precisely, the bounding
box of the glyph that represents the button on the screen.} The
latter is true if and only if the button has been pressed, but not
yet released, within the bounding box of the button. When a button is
released within the button, its \Scala{react} method is
invoked.\footnote{with a parameter, sometimes ignored, that captures the
current state of the keyboard modifiers, the exact button pressed, etc.}

A button can be programmatically disabled or made inactive:
\begin{scala}
    var disabled: Boolean
    var inactive: Boolean
\end{scala}

The first part of the definition is straightforward: the constructor
takes the glyph used to specify the button's appearance when neither
hovered nor pressed. The brushes \Scala{down} and \Scala{hover} specify
the foreground colour of the glyph when hovered and pressed, and when
just hovered. If the colour of the background is to be changed on
state changes, then \Scala{background} is set.

\begin{scala}
class ColourButton(
  appearance:     Glyph,
  down:           Brush,
  hover:          Brush,
  val background: Boolean, 
  val react:      Reaction) extends GenericButton {
  
  override def toString: String =
           s"ColourButton($up, $down, $hover, $background)"
\end{scala}

Because we cannot rely on the \Scala{fg} (\Scala{bg}) brush of the appearance
not being shared anywhere else in the GUI tree, we want to avoid
changing that brush. So we construct a \textit{copy} (\Scala{glyph})
of the appearance glyph, with \Scala{fg} (\Scala{bg}) set to \Scala{currentBrush}
-- a copy of the appearance's relevant brush. We intend to use
\Scala{glyph} when drawing the button; its  (background)  will
be painted using the copied brush, and the appropriate features of
that brush will be copied (from one of \Scala{up, down, hover})
according to the current state of the button.

\begin{scala}
   val up: Brush =
       if (background) appearance.bg else appearance.fg

   val currentBrush: Brush = up.copy()

   val glyph: Glyph        =
       if (background)
          appearance(bg=currentBrush)
       else
          appearance(fg=currentBrush)

   def setCurrentBrush(b: Brush): Unit = {
      currentFG.color(b.color).width(b.strokeWidth)
    }
\end{scala}

The \Scala{draw} method shows the current state of the
button by painting it with the appropriate brush using
the appropriate opacity (alpha).
It captures the current geometric transform that
will be used to render its glyph.\footnote{ The latter is used to
speed up the tracking of mouse movements. If the button is inactive or disabled,
it won't be used, but capturing it does no harm.}

\begin{scala}
    def draw(surface: Surface): Unit = {
        val (brush, alpha) = 
            if (disabled) (up, alphaDisabled) else
            if (inactive) (up, alphaUp) else
            (pressed, hovered) match {
              case (true, true)  => (down,  alphaDown)
              case (false, true) => (hover, alphaHover)
              case (_, _)        => (up,    alphaUp)
            }
        surface.withAlpha(diagonal, alpha) {
          setCurrentBrush(brush)
          glyph.draw(surface)
          surface.declareCurrentTransform(this)
       }
   }
\end{scala}

The following definitions
can be overridden if necessary, but have proven satisfactory in practice.

\begin{scala}
    def alphaDisabled: Int = 0x70;  def alphaUp:       Int = 0xFF
    def alphaDown:     Int = 0xFF;  def alphaHover:    Int = 0xF0
\end{scala}

The actual glyph that will be shown must be properly installed in the GUI
tree by making the button glyph its parent.

\begin{scala}
    locally { glyph.parent = this }
\end{scala}

The rest of the button glyph description is completely standard: it
implements the remaining glyph features by forwarding to
its ``embedded'' \Scala{glyph}.
\begin{scala}
    override def diagonal: Vec = glyph.diagonal

    override def glyphContaining(p: Vec): Option[Hit] =
                 glyph.glyphContaining(p)

    override def contains(p: Vec): Boolean =
                 glyph.contains(p)

    val fg: Brush = glyph.fg
    val bg: Brush = glyph.bg

    def copy(fg: Brush=this.fg, bg: Brush=this.bg): Glyph =
        new ColourButton(appearance(fg.copy(), bg.copy()), down, hover, react)

  }
\end{scala}

As usual we define a companion object to deliver methods
that support the convenient construction of useful \Scala{ColourButton}s.
The first one we show here provides a text-labelled button
using the various defaults provided by \Scala{Brushes}. The defaults
can be overridden at construction time.

\begin{scala}
object ColourButton {
 val up:    Brush = Brushes.buttonForeground()
 val down:  Brush = Brushes.buttonDown()
 val hover: Brush = Brushes.buttonHover()
 val bg:    Brush = Brushes.buttonBackground
 def apply(text:  String,
           up: Brush=up, down: Brush=down, hover: Brush=hover,
           bg: Brush=bg, background: Boolean = true)
          (react: Reaction): ReactiveGlyph =
 { val glyph: Glyph = Brushes.buttonText(text).asGlyph(up, bg)
   new ColourButton(glyph, down, hover, background, react)
 }

 def apply(glyph:Glyph,down:Brush,hover:Brush,background:Boolean)
          (react: Reaction): ReactiveGlyph =
     new ColourButton(glyph, down, hover, background, react)
}
\end{scala}
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\S{Examples}

The best way of getting to grips with \textbf{Glyph} is to study
the source of one or two of the medium-sized examples included with
it: particularly \Scala{DemonstrationNotebook}, and
\Scala{CalculatorExample}. The following few examples are considerably smaller,
and not particularly useful save as a getting-started guide. The use of
implicit style parameters in examples 3 and 4 means that the reader should be
somewhat familiar with the notion of implicits in Scala 2.

\SS{A Passive GUI}

This is an entirely passive application.
Its ``interface'' is an (unstyled) text label.
The abstract class \Scala{Application} provides the link between
the interface and the outside world, needing only a definition of
\Scala{GUI} to set up and populate its single main window.

\begin{scala}
package org.sufrin.glyph.tests
import  org.sufrin.glyph._
import Glyphs.Label

object Example1 extends Application  {
  val GUI: Glyph = Label("A simple label")
  override def title: String = "Example 1"
}
\end{scala}

On my computer, the text of the label seems a bit close to the
inner edge of the window: so our first modification to the
program will be to add an uncoloured
20 \textbf{ux}\footnote{Distance measurements are
expressed in (possibly fractional) ``logical units'' (ux) -- these sometimes correspond
to the physical pixels on a screen, but on some high-resolution
screens a \textbf{ux} may correspond to more than one
pixel. \Textbf{Glyph} manages the correspondence.} border around the label.
The colours and font of unstyled labels are given default values in
the definition of \Scala{Label}.

\begin{scala}

val GUI: Glyph = Label("A simple label").enlarged(20)
\end{scala}

The effect is discernible but not drastic.

\begin{center}
\pdffig[scale=0.35]{PNG/example1b}
\quad
\pdffig[scale=0.35]{PNG/example1a}
\end{center}

\SS{An Explicitly-styled GUI}

This application's interface is defined as \Scala{GUI} 
in the trait \Scala{Example2Interface} that is mixed-in with
\Scala{Application} to form the main program.

\begin{scala}
package org.sufrin.glyph.tests
import org.sufrin.glyph._
import Glyphs._
import NaturalSize.{Row,Col}
import ReactiveGlyphs.TextButton
\end{scala}

\begin{scala}
trait Example2Interface { ... }

object Example2 extends Application  with Example2Interface {
  override def title: String = "Example 2"
}
\end{scala}

\begin{center}
\pdffig[scale=0.35]{PNG/example2a}
\end{center}

The interface is a centered column, on which there is
a label above two side-by-side captioned buttons, each with a
rounded blue frame around it. It is presented on a grey background with a
yellow rim around it

\begin{scala}
trait Example2Interface {
  val blueish:    Brush = blue(cap=ROUND, width=8)
  val labelColor: Brush = green()

  val GUI: Glyph = Col(bg=lightGrey).centered(
    Label("A simple label", fg=white) enlarged(20, bg=labelColor),
    Row(TextButton("make it blue") { _ => labelColor color blue.color }
        .framed(fg=blueish, bg=blueish)
       ,
        TextButton("make it red") { _ => labelColor color red.color }
        .framed(fg=blueish, bg=blueish))
  ).enlarged(40f).enlarged(20f, bg=yellow)

}
\end{scala}

A \Scala{TextButton}'s default response to the mouse cursor entering
it is to turn its caption green; when the cursor is pressed in this
state the caption turns red, and if the cursor is released when the
caption is red, then the button's reaction method is invoked. Here,
each button's reaction changes the colour \Scala{labelColor} that
was used to paint the background around the label.

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%


\SS{A GUI with Implicitly Styled Glyphs}

This application was derived from example 2, and has an almost
identical source code structure, save that the button and label
definitions are imported from the \Scala{styled} package.

\begin{scala}
package org.sufrin.glyph.tests
import org.sufrin.glyph.Glyphs._
import org.sufrin.glyph.NaturalSize._
import org.sufrin.glyph._

trait Example3Interface { ... }

object Example3 extends Application  with Example3Interface {
  override def title: String = "Example 3"
}
\end{scala}

Its interface looks almost the same as the previous example, save
that the button framing is a little more elegant, and the simple
label is in a larger font, and placed on a coloured background

\begin{center}
\pdffig[scale=0.35]{PNG/example3a}
\end{center}

The \Scala{Example3Interface} is different: it uses \textit{implicitly-styled}
glyphs and leaves much of the heavy lifting concerning font sizes, and button
frames to be defined implicitly by the \textit{enclosing context}. Here that
context is provided by importing the  \Scala{LocalStyle} object:

\begin{scala}
trait Example3Interface {
  object LocalStyle extends Styles.Basic { ... }
  import LocalStyle._
  import Spaces._
  import styled.TextButton
  import styled.TextLayout.TextLabel

  val labelColor: Brush = green()

  val GUI: Glyph = Col(bg=lightGrey).centered(
    TextLabel("A simple label") enlarged(20, bg=labelColor), ex,
    Row(TextButton("make it yellow") { _ => labelColor color yellow.color },
        TextButton("make it red")    { _ => labelColor color red.color })
  ).enlarged(40f).enlarged(20f, bg=yellow)

}
\end{scala}

The \Scala{LocalStyle} object is an extension of \Scala{Styles.Basic} that
specifies a variety of styles by default. Here we adapt two of the
defaults for use in styling our labels and our buttons. They are
declared as \Scala{implicit}, and the compiler matches them to
the implicit parameters of \Scala{TextLabel} and \Scala{TextButton}: their
names are unimportant: the implicit matching is done on their types.

\begin{itemize}
\item \Scala{localLabels} is almost identical to the basic \Scala{labelStyle},
except that its font is made (with the same \Scala{face}) at a different size.

\item \Scala{localButtons} is almost identical to the basic \Scala{buttonStyle},
except that buttons are specified as being framed with round blue frames
on a white background. 
\end{itemize}

\begin{scala}
  object LocalStyle extends Styles.Basic {
    import Styles.Decoration.Framed
    
    implicit val localLabels: Styles.GlyphStyle =
      labelStyle.copy(font=GlyphTypes.Font(face, 40))
    }

    implicit val localButtons: Styles.ButtonStyle =
      buttonStyle.copy(frame =
        Framed(fg = blue(width = 8, cap=SQUARE), bg = red))
\end{scala}

\clearpage
Less rounded button frames can be delivered by adopting a higher curvature
(lower radius factor), and the frames are square when no radius factor (or a factor of $0$)
is specified.

\begin{scala}
  implicit val localButtons: Styles.ButtonStyle =
    buttonStyle.copy(
       frame = Framed(fg = blue(width = 8, cap=SQUARE), bg = red)
    )
\end{scala}

\begin{center}
\pdffig[scale=0.30]{PNG/example3b}
\end{center}

There are other kinds of button-framing, including \Scala{Shaded}, and \Scala{Blurred}

\begin{scala}
  import Styles.Decoration.{Shaded, Blurred}
  
  implicit val localButtons: Styles.ButtonStyle =
    buttonStyle.copy(frame = Shaded(fg = blue(width = 8), bg = red))

  implicit val localButtons: Styles.ButtonStyle =
    buttonStyle.copy(frame = Blurred(blur=10f, spread=10f, fg = yellow))
\end{scala}


\begin{center}
\pdffig[scale=0.30]{PNG/example3c}
\quad\pdffig[scale=0.27]{PNG/example3d}
\end{center}

The important thing to understand is that all styles deliver buttons with the
same functionality: this means that the  visual style of an interface can
straightforwardly be decided upon separately from its functionality.

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%


\SS{A Primitive Calculator}


\begin{center}
\pdffig[scale=0.30]{PNG/example4}
\end{center}

The application also uses styled components; but this time keeps to the basic standard.

\begin{scala}
package example4
import org.sufrin.glyph.NaturalSize.{Col, Row}
import org.sufrin.glyph._
import styled.TextLayout._

object Style extends Styles.Basic
import Style._

trait Interface {
  ...
  val GUI: Glyph = Col.centered(
    help enlarged 25,
    Row.centered(c.framed(), TextLabel(" = "),
                 a.framed(), TextLabel(" + "), b.framed())
  ) enlarged(25)
}
\end{scala}

Its \Scala{Interface} trait defines its help text, three identically-behaving
text (input) fields \Scala{a, b, c}, and a couple of helpful methods.


\begin{scala}
trait Interface {
  val help = TextParagraphs(50, Justify)("...")

  def field(): TextField =
      TextField(size = 8, onEnter = { _ => calculemus() })

  val a, b, c = field()

  def calculemus() = ... 

  val GUI: Glyph = ...
}
\end{scala}

The most important of
these methods is \Scala{calculemus()}. It is the core of the application: when invoked
-- by \textsf{ENTER} being typed in any of the text fields -- it tries to convert each of the text
fields into numbers, then calculates the third if at least two are defined.


\begin{scala}
def calculemus() = 
 (c.text.toDoubleOption, a.text.toDoubleOption, b.text.toDoubleOption)
  match {
     case (None, Some(av), Some(bv)) => c.text = format(av+bv)
     case (Some(cv), Some(av), None) => b.text = format(cv-av)
     case (Some(cv), None, Some(bv)) => a.text = format(cv-bv)
     case (Some(cv), Some(av), Some(bv)) =>
          if (cv == av+bv) {} else c.format = text(av+bv)
     case _ =>
   }
   
def  format(d: Double): String = f"$d%.5g"
\end{scala}

A slightly different definition of the behaviour of the text fields, allows
a simple error report to be given if what's in a field doesn't look like
a number when enter is pressed.

\begin{scala}
import windowdialogues.Dialogue.OK

def field(): TextField = TextField(size = 8, onEnter = {
    case s: String if s.toDoubleOption.isDefined => calculemus()
    case s: String =>
      OK(TextLabel(s"$s doesn't look like a number."))
        .InFront(help)
        .start()
  })
\end{scala}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\S{Pages from {DemonstrationNotebook}}

Figures \ref{Help} to \ref{Events-Events} show some of the pages
of the \texttt{DemonstrationNotebook} example. They are intended to
illustrate some of the available tools in use, and their source
code shows how the tools can be used.

The  (top-level) notebook is structured as
a sequence of pages with titles. Pages may themselves
have nested notebooks, as exemplified by the
\Scala{"Etc*"} page below.

The \Scala{Layout} feature of a notebook supports methods, such as
\Scala{rightButtons}, \Scala{leftButtons}, ... whose invocation
yields a GUI with buttons juxtaposed to a \Scala{OneOf} that has
a glyph for each defined page.


\begin{scala}
trait DemonstrationPages
     ...
     
     val noteBook = new NoteBook
     val Page = noteBook.DefinePage
     
       Page("Help", "Help for the Demonstration Notebook") {...}
       Page("New", "Make a new or cloned GUI ") {...} 
       Page("Menus*", "Window menus and dialogues") {...}
       Page("Transforms*", "") {...}
       Page("Overlays*", "Features implemented as ...") {...}
       Page("Framing*", "") {...}
       Page("Styles*", "") {...}
       Page("Events*", "") {...}
       Page("Fonts*", "..") {...} (HelpStyle.labelStyle)
       Page("Etc*", "") {
        val nested = new Notebook {}
        val Page = nested.DefinePage
        Page("Animation", "") {...}
        Page("Grid", "12 blurred-frame buttons shown in grids") {...}
        Page("Blurred", "") {...}
        Page("Scroll", "Scrolling and Scaling with ViewPort") {...}
        Page("OneOf", "OneOf backgrounds") {...}
        Page("CheckBox", "Toggles and Checkboxes") {...}
        nested.Layout.rightButtons()
      }
      
      ...
\end{scala}

\clearpage
Each of the lazy values defined
below is bound to one particular notebook layout; and the
top-level application logic chooses one of them as the GUI
for the application. Figure \ref{Framing-Text1 |Skewed Tabs|} illustrates
the ``skewed buttons'' presentation style.
\begin{scala}
     ...
     lazy val asRNotebook = noteBook.Layout.rightButtons()
     lazy val asLNotebook = noteBook.Layout.leftButtons()
     lazy val asVNotebook = noteBook.Layout.rotatedButtons(3)
     lazy val asSNotebook = noteBook.Layout.skewedButtons(0.2f, 0f)
     lazy val asTNotebook =noteBook.Layout.topButtons()
     
} // end DemonstrationPages
\end{scala}

The application as a whole is an instance of the Glyph \Scala{Application} trait --
that provides definitions of \Scala{GUI}, \Scala{Title}, \textit{etc.}
Importantly the standard \Scala{onClose} method invokes a method that
pops up a dialogue that asks for confirmation when the application window is closed.

\begin{scala}
object DemonstrationNotebook extends DemonstrationPages with Application {
  lazy val GUI =
       if (extraArgs contains "-notebook")   asRNotebook else
       if (extraArgs contains "-rnotebook")  asRNotebook else
       if (extraArgs contains "-lnotebook")  asLNotebook else
       if (extraArgs contains "-snotebook")  asSNotebook else
       if (extraArgs contains "-vnotebook")  asVNotebook else
       if (extraArgs contains "-tnotebook")  asTNotebook else
       if (extraArgs contains "-menu") asMenu else asRNotebook

  def title =
      s"""SmallTest -scale=$scaleFactor ${extraArgs.mkString(", ")}"""

  override
  val defaultIconPath: Option[String] = Some ("./flag.png")

  override
  def onClose(window: Window): Unit = confirmCloseOn(GUI)(window)
}
\end{scala}


\begin{comment}
\begin{scala}
  def confirmCloseOn(glyph: Glyph)(window: Window): Unit = {
    import windowdialogues.Dialogue.OKNO
    val prompt =
      Row.centered(PolygonLibrary.closeButtonGlyph scaled 5 enlarged(50),
                   TextLabel("Do you want to Exit?")(HugeLabelStyle) scaled 0.7f
                ).enlarged(50)
    OKNO(prompt,
         title="Exit Dialogue", ok=" Exit now ", no=" Continue ").InFront(glyph).andThen{
            case close => if (close) window.close()
         }
  }
\end{scala}
\end{comment}

\SAVEDFIG Help/the Help page/
\SAVEDFIG New/the New page/
\SAVEDFIG Menus-Dialogues/the Dialogues subpage of Menus* /
\SAVEDFIG Transforms-Turn/the Turn subpage of Transforms* /
\SAVEDFIG Transforms-Tight/the Tight subpage of Transforms* /
\SAVEDFIG Transforms-Skew/the Skew subpage of Transforms* /
\SAVEDFIG Transforms-Mirror/the Mirror subpage of Transforms* /
\SAVEDFIG Overlays-Annotation/the Annotation subpage of Overlays* /
\SAVEDFIG Overlays-Dialogues/the Dialogues subpage of Overlays* (vertical tabs notebook)/
\SAVEDFIG Overlays-Dialogues-PoppedUp/a Popped-up dialogue (vertical tabs notebook) /
\SAVEDFIG Framing-Text1 |Skewed Tabs|/the Text1 subpage of Framing* (skewed tabs notebook) /
\SAVEDFIG Framing-Text2/the Text2 subpage of Framing* /
\SAVEDFIG Framing-Framed/the Framed subpage of Framing* /
\SAVEDFIG Framing-Edged/the Edged subpage of Framing* /
\SAVEDFIG Styles-Framed/the Framed subpage of Styles* /
\SAVEDFIG Styles-Blurred/the Blurred subpage of Styles* /
\SAVEDFIG Events-Events/the Events subpage of Events* /
\SAVEDFIG Etc-Animation/the Animation subpage of Etc* (mid-animation) /
\SAVEDFIG Etc-Blurred/the Blurred subpage of Etc* /
\clearpage

\section*{Acknowledgements}
This work would not have been possible were it not for the
open source \href{https://skia.org/}{\textbf{Skia}},
\href{https://github.com/HumbleUI/HumbleUI}{\textbf{Skija}},
and \href{https://github.com/HumbleUI/JWM}{\textbf{JWM}} projects.

I am grateful to Sasha Walker\Footnote{$*$}{Of Magdalen College,
and the Department of Computer Science, Oxford University},
for her patience in waiting for me to develop the initial working prototype of this
library, and for her tolerance when listening to explanations of my implementation
of the focus protocol. 

Dominic Catizone\Footnotemark{$*$} made a remark that helped me solve a
problem with designing the geometry of (non-quadrant) rotations of bounding boxes.
\end{document}

