%xelatex
\documentclass[12pt,a4paper]{article}
\def\DRAFT{}% comment out to include all the saved images at the end
%%%%%%%%%%%%%%%%%%%%%
%% \usepackage[]{Tex/ordinal}
%% \usepackage{fontspec}
%% \setmainfont{texgyrepagella}[
%%   Extension = .otf,
%%   UprightFont = *-regular,
%%   BoldFont = *-bold,
%%   ItalicFont = *-italic,
%%   BoldItalicFont = *-bolditalic,
%% ]
%% \usepackage{unicode-math}
%% \setmathfont{STIXTwoMath-Regular.otf}
%%%%%%%%%%%%%%%%%%%%%
\usepackage{xspace}
\def\Glyph{\textbf{Glyph}\xspace}
\def\Skia{\textbf{Skia}\xspace}
\def\ux{\textbf{ux}\xspace}
%%%%%%%%%%%%%%%%%%%%%
\usepackage{scalalistings}
\usepackage{verbatimstyle}
\usepackage{pdffig}
\usepackage{manyfoot}
\usepackage{alltt}



\def\glyph[#1]#2{
\begin{center}
\marginpar{\textsf{\scriptsize{\\[16ex]Glyph\\#2}}}
\penalty-2000\pdffig[#1]{PNG/cap-#2}\\
\end{center}
}

\def\cglyph[#1]#2{
\begin{center}
%\marginpar{\textsf{\scriptsize{\\[16ex]Glyph\\#2}}}
\penalty-2000\pdffig[#1]{PNG/cap-#2}\\
\end{center}
}



\def\smallglyph[#1]#2{
\bgroup
\footnotesize
\penalty-1000\textsf{Glyph #2}\\[1ex]
\penalty-1000\pdffig[#1]{PNG/cap-#2}\\
\egroup
}

\def\sample[#1]#2{
\begin{center}
\penalty-1000\pdffig[#1]{PNG/cap-#2}
\end{center}
}

\def\PNGfig[#1]#2{
%\penalty-1000
\pdffig[#1]{PNG/#2}
}

\def\samples[#1]#2#3{
\begin{center}
\pdffig[#1]{PNG/cap-#2}\quad\quad\quad
\pdffig[#1]{PNG/cap-#3}
\end{center}
}

\def\SAVEDFIGURE#1#2{
\ifdefined\DRAFT
\begin{figure}
\caption{\textit{#1}: #2}
\label{#1}
\end{figure}
\else
\begin{figure}[h]
\begin{center}
\pdffig[scale=0.36]{SAVED/#1}
\caption{#2}
\label{#1}
\end{center}
\end{figure}
\fi
}

\def\PNGFIGURE[#1]#2#3{
\begin{figure}[tb]
\begin{center}
\pdffig[#1]{PNG/#2}
\caption{#3}
\label{#2}
\end{center}
\end{figure}
}


\def\SAVEDFIG#1/#2/{\SAVEDFIGURE{#1}{#2}}

\def\Scala#1{\textcolor{blue}{\textsf{#1}}}

\let\scalasize=\footnotesize
\let\scalainlinesize=\small
\def\scalafamily{\sffamily}
\verbatimfamily{\sffamily}

\parindent=0pt
\parskip=\medskipamount


%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{sectsty}
\usepackage{titlesec}
\usepackage{color}
\usepackage[bookmarks,hypertexnames=false,debug,linktocpage=true,hidelinks]{hyperref}

\hypersetup{
    colorlinks,
    linktoc=all,
    linkcolor={blue},
    citecolor={blue},
    urlcolor={blue}
}

%%%%%%%%%%%%%%%%%%%%%
\def\S#1{\section{#1}}
\def\SS#1{\subsection{#1}}
\def\SSS#1{\subsubsection*{#1}}

%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
\author{Bernard Sufrin\thanks{Emeritus Fellow: Department of Computer
Science \& Worcester College, Oxford; Tutor in Computer Science,
Magdalen College, Oxford}}
\title{The \Glyph User-Interface Library for Scala}
\date{Draft of \today}
%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\maketitle
\begin{abstract}

Here we introduce the \Glyph user-interface library for Scala.  Its
graphical features are geometrically compositional:  rendered using
a small subset of the facilities of  Google's \Skia{\footnote{\Skia
is a highly portable 2-D graphics library used in the implementation of several
browsers, including Chrome.}}, as delivered (in the JVM) by the \textbf{Skija}
library.\footnote{The present prototype
runs on Linux, Windows, OS/X (both x86 and Apple Mx processors)}
%
Our motivation for developing the library was our frustration, over many years,
with complex UI frameworks that impose a uniform style, and that make
it hard to develop novel modes of interaction.\footnote{There is
nothing wrong with uniform styling: but the cost of straying outside
the styling envelope needs to diminish. An interface designer
who doesn't mind learning a new language (Dart) and staying within its
envelope might be rewarded by investigating Google's
\href{https://api.flutter.dev/index.html}{Flutter}.} 

What has guided this work is the idea that a rich set of interactive
interface components can be composed using a small collection of combining
forms, and a suitable collection of elementary visual
and reactive components.

Instead of (just) providing a uniformly-styled ``high level''
toolkit, we have provided enough elements and combining forms for
an innovative UI designer to experiment with, and a collection of
implementations of conventional components (for example buttons,
checkboxes, text input components, notebooks) to serve as models.

Code, along with several  example programs to demonstrate principles,
can be found in the public repository at
\begin{center}
\href{https://github.com/sufrin/Glyph}{https://github.com/sufrin/Glyph}.
\end{center}\vfill
\end{abstract}
\clearpage
\tableofcontents
\clearpage
\listoffigures
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%


\S{User Interfaces with Glyph}
\SS{Introduction}

A complete \Glyph user interface (GUI) is specified as a tree of
\SCALA{Glyph} components, that may be \textit{passive}, \textit{active},
or \textit{reactive}.  Composite nodes of the tree consist of
collections of components that share the same bounding box -- being
juxtaposed geometrically or temporally within it.

For example, suppose \SCALA{a}'s bounding box is 5 units wide and 3
units high; and that of \SCALA{b} is the same width and 1 unit height
-- perhaps as painted\footnote{A glyph's colour and visual texture
is specified by its foregound and background: both determined
by properties of the \SCALA{Brush}es used to paint it.} respectively yellow and green) by:

\begin{scala}
  def a = FilledRect(5*units, 3*units, fg=yellow)
  def b = FilledRect(5*units, 1*units, fg=green)
\end{scala}
then
\begin{scala}
                Row(Col(a, b), Col(a, b))
\end{scala}
has a bounding box that is the horizontal catenation of 2 copies
of the bounding box of \SCALA{Col(a, b)}; the latter has a bounding
box that is the vertical catenation of the bounding boxes of \SCALA{a},
\SCALA{b}. The outcome will be drawn as:\footnote{We have added thin frames around
$a$ and $b$ to show their extents within the bounding box.}


\begin{center}
\pdffig[scale=0.6]{PNG/eg1a}
\end{center}

The height of a row is the maximum height of its components; its width is
the sum of its components' widths; and a row is normally drawn with its
components aligned along its top edge.

So exchanging \SCALA{Col} and \SCALA{Row}
in the above leads to:
\begin{center}
\PNGfig[scale=0.6]{eg1b}
\end{center}
The glyph trees for the two images are:
\begin{scala}
           Row                     Col
           +--Col                  +--Row 
           |  +--  a               |  +--a
           |  +--  b               |  +--b
           +--Col                  +--Row 
              +-- a                   +--a
              +-- b                   +--b
\end{scala}


We will later show other ways of composing glyphs.

\SS{Reactive Glyphs and Focus}

Reactive glyphs are the means by which user actions, such as mouse
gestures and keystrokes, are coupled to the semantic actions of the
application they control. As usual these actions can 
result in changes to the appearance of the interface.

Unless it is just a passive image in a window, one or more of the
nodes in the glyph tree of a GUI will be a \SCALA{ReactiveGlyph}
-- designed to respond to specific user actions such as gesturing
at a window with mouse or trackpad, or typing a keystroke.

Interaction with the GUI in a window is mediated by its associated
\SCALA{Interaction} component, whose primary role is to determine
which reactive glyph a user's action or a system-reported event is
to be directed at, and to direct it there. To this end 
with each window is associated a \Scala{keyboardFocus}, and a
\Scala{mouseFocus}  variable -- both of type
\Scala{Option[ReactiveGlyph]}. These are managed by the
\Scala{EventHandler} module of its associated \Scala{Interaction},
which implements the \textit{Focus Protocol} described
in detail in Appendix \ref{thefocusprotocol}.

\begin{comment}
\footnote{A window's \Scala{RootGlyph}
also manages the ancillary glyph trees associated with the implementation
of dialogues, menus, and transient decorations. The management of ancillaries
lends an element of complexity to the protocol implementation, but
a detailed discussion is not needed here.}

\footnote{\textit{via} the standard
reactive \Scala{RootGlyph} component that contains every
GUI tree as its single branch.} 
\end{comment}

\SSS{Mouse Focus}
Normally, a mouse event (mouse motion, mouse button press or release)
is directed at the reactive glyph that has the mouse focus -- this
is almost always the reactive glyph within whose bounding box the mouse
cursor is shown. When the mouse cursor strays outside the currently
mouse-focussed glyph a \Scala{GlyphLeave} event is directed
at the glyph, and we say that the mouse focus is 
\textit{uncommitted}.  The mouse focus
stays uncommitted until the cursor moves into a(nother) reactive glyph.
The focus is now committed to this glyph, which is informed of it
by being sent a \Scala{GlyphEnter} event.

\SSS{Keyboard Focus}
A reactive glyph, such as  one that is going to respond to typing,
will normally ``grab'' the keyboard focus when it receives a
\Scala{GlyphEnter} event, and \textit{may} give it up when it
receives a \Scala{GlyphLeave} event.\footnote{We write \textit{may}
because some glyphs do not require the mouse to be inside them in
order to respond to the keyboard.} Any reactive component can acquire
or be given the keyboard focus at any time; and can give it up or give
it away at any time.\footnote{Perhaps surprisingly, keyboard-focus-gained and keyboard-focus-lost events
have not, so far been needed.}

Normally a keyboard event is directed at the reactive glyph that
has the keyboard focus; when there is no such glyph, then it is
first directed at the glyph that previously held the keyboard focus;
and if there is no such glyph then the ``orphan'' event is (usually)
ignored.\footnote{We write \textit{usually} because there is
additional provision for catching and acting upon unfocussed keyboard
events that can in principle be used to give some sort of feedback.}



%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\S{Glyphs}
\SS{The Glyph Interface}

The unit of graphical composition is the \SCALA{Glyph}. All implemented \SCALA{Glyph}s:

\begin{enumerate}
        \item Define how they are to be ``painted'' on a
        \SCALA{Surface}\footnote{A Surface
        implements the primitive methods that are used to paint
        shapes.}
        
        Painting instructions always use a \textit{local co-ordinate space}
        with origin at $(0,0)$. 

        \item Define the \SCALA{Brush}es to be
        used when they are painted: usually by specifying foreground and
        background brushes.

        \item Define the diagonal of the rectangular bounding box they
        will occupy on the surface.

        \item Define the location of the top left corner of the
        abovementioned bounding box relative to the origin of the
        bounding box of their parent in the glyph-tree. This is
        usually determined when the parent glyph is laid out; and
        happens for the first time during the composition
        of the parent.

        \item Define a method that yields a \textit{structurally identical} copy
        of the glyph: perhaps one that uses different brushes.     
\end{enumerate}

A purely passive graphical glyph may be elementary (simple), or composite. 
Simple glyphs are constructed by \textit{Glyph factories},
many of which require no more than a specification of the
diagonal of the bounding box of the graphic: its foreground and background
brushes can be specified explicitly or by default.
%
The actual location of a glyph when painted on its surface is usually
defined by its location relative to its parent in the glyph tree.

Although a glyph type is usually \textit{defined} by a Scala class,
our API convention is that instances used in application GUIs are
almost invariably \textit{constructed} by one of the methods of the
Scala companion object of its class. For example

\begin{scala}
 FilledRect(w: Scalar, h: Scalar,    fg: Brush=..., bg: Brush=...)
 Rect(w: Scalar, h: Scalar,          fg: Brush=..., bg: Brush=...)
 FilledOval(w: Scalar, h: Scalar,    fg: Brush=..., bg: Brush=...)
 Label(text: String, font: Font = ...fg: Brush=..., bg: Brush=...)
 Polygon(w: Scalar, h: Scalar,
         fg: Brush=..., bg: Brush=...)(points: ...)
\end{scala}




\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%



\SS{Glyph Composition}

Composite glyphs are specialised instances of the \SCALA{Composite}
extension of \SCALA{Glyph}, and are also usually constructed by
\textit{Glyph factories}. These include:

\begin{scala}

        Row             Col
        Concentric      OneOf
\end{scala}

The \Scala{Row} and \Scala{Col} compositions are (almost)
explainable by their names. Each has variants that
explain the exact way in which components are aligned. Here
are three differently-aligned rows of a pair of rectangles:\footnote{
\Scala{Row} and \Scala{Row(align=Top)}
mean the same. We will later meet \Scala{Row(align=Baseline)(...)}.}
\begin{center}
\pdffig[scale=0.5]{PNG/row-t}
\quad\quad
\pdffig[scale=0.5]{PNG/row-c}
\quad\quad
\pdffig[scale=0.5]{PNG/row-b}
\end{center}
\begin{scala}
   Row(align=Top)(b,r) Row(align=Mid)(b,r) Row(align=Bottom)(b,r)
\end{scala}






Here are three differently-aligned columns of a pair of rectangles:\footnote{
\Scala{Col}, and \Scala{Col(align=Left)} mean the same.}

\begin{center}
\pdffig[scale=0.5]{PNG/col-l}
\quad\quad
\pdffig[scale=0.5]{PNG/col-c}
\quad\quad
\pdffig[scale=0.5]{PNG/col-r}
\end{center}
\begin{scala}
   Col(align=Left)(b,r) Col(align=Center)(b,r) Col(align=Right)(b,r)
\end{scala}

The row and column compositions described above yield glyphs that
are ``naturally'' sized. Thus, for example, a row's width is the
sum of its components' widths, and its height is the maximum of its
components' heights. There are also fixed-size row (and column)
compositions, whose row width and column height can be declared in advance,
and that allow ``expandable'' spaces as components. Here we see a couple of examples:\footnote{\Scala{tab} is
an expandable space.}

\begin{center}
\pdffig[scale=0.45]{PNG/row-fixed}
\quad\quad
\pdffig[scale=0.45]{PNG/row-fixed-j}
\end{center}

These were constructed by:
\begin{scala}
import FixedSize.Space.tab
FixedSize.Row(350f, bg=grey)(tab, redR, blueR, redR)
FixedSize.Row(350f, bg=grey)(redR, tab, blueR, tab, redR)
\end{scala}
with
\begin{scala}
def redR:  Glyph = FilledRect(50f, 25f, fg=red)
def blueR: Glyph = FilledRect(100f, 25, fg=blue)
\end{scala}

Finally, below we show three of the possible \SCALA{Concentric} 
compositions of a point and a pair of rectangles; respectively:
\begin{scala}
        Concentric(rowAlign=Mid, colAlign=Center)(p,b,r)
        Concentric(rowAlign=Mid, colAlign=Right)(p,b,r)
        Concentric(rowAlign=Top, colAlign=Center)(p,b,r)      
\end{scala}

\begin{center}
\pdffig[scale=0.5]{PNG/conc} 
\quad\quad
\pdffig[scale=0.5]{PNG/conc-t}
\quad\quad
\pdffig[scale=0.5]{PNG/conc-r} 
\end{center}


The vertical and horizontal aspects of their alignments are, in general,
specified independently; but there are shorthands for common cases. Here
we could have written:

\begin{scala}
        Concentric.Center(p,b,r)
        Concentric.Top(p,b,r)
        Concentric.Right(p,b,r)      
\end{scala}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\SSS{Grid and Table organization}
It can also be helpful to organize glyph sequences in tabular
form. Several methods for doing
this are provided by \Scala{NaturalSize.Grid} --
all invoked by first specifying various aspects of the table.


\begin{alltt}\textcolor{blue}{Grid(fg: Brush=nothing, bg: Brush=nothing, padx: Scalar=0, pady: Scalar=0).\(method(...)\)}
\end{alltt}

The main $method$s of such a \Scala{Grid} are:
\begin{scala}
  Grid(width:  Int=0, height: Int=0)(glyphs: Glyph*):      Composite
  Table(width: Int=0, height: Int=0)(glyphs: Glyph*):      Composite
  Rows(width:  Int=0)                (glyphs: Glyph*):     Composite 
  Cols(height: Int=0)                (glyphs: Glyph*):     Composite 
  grid(width:  Int=0, height: Int=0)(glyphs: Seq[Glyph]):  Composite
  table(width: Int=0, height: Int=0)(glyphs: Seq[Glyph]):  Composite
  rows(width:  Int=0)                (glyphs: Seq[Glyph]): Composite
  cols(height: Int=0)                (glyphs: Seq[Glyph]): Composite
\end{scala}

Methods with \Scala{width}, \Scala{height}, and \Scala{glyphs} formal parameters interpret
their \Scala{glyphs} actual parameter as follows:\footnote{In this section \Scala{width} means ``number of columns''; and \Scala{height} means
``number of rows.}
\begin{enumerate}
     \item  if there's a \Scala{width} parameter then glyphs is interpreted as a catenation of rows of the given \Scala{width}
     \item if there's a \Scala{height} parameter then glyphs is interpreted as a catenation of columns of the given \Scala{height}
     \item if there are both \Scala{width} and \Scala{height} parameters, then:
    \begin{enumerate}
         \item if one argument is omitted,
         \Scala{glyphs} is interpreted as if the method had only the other formal parameter (as above)
         \item if  both arguments are omitted then \Scala{width} is taken to be \Scala{ceiling(sqrt(glyphs.length))}.
    \end{enumerate}
\end{enumerate}


The \Scala{grid/Grid} methods present a grid of
\textit{identically-dimensioned} cells,
each large enough for any of the glyphs.

The \Scala{table/Table} methods present a grid in which 
all cells in each column have the same horizontal dimension, and all cells in each row
row have the same vertical dimension.

The \Scala{rows/Rows} methods present a grid of row data with columns of uniform horizontal dimension, whilst
analogously  \Scala{cols/Cols} presents a grid of column data with rows of uniform vertical dimension.

Figures \ref{gridorder}, \ref{gridtable} and  \ref{gridcellFit} illustrate several ways of using
the \Scala{Grid} methods \Scala{grid}, and \Scala{table}.




Individual glyphs in a grid can be made to fit their cell by
various methods, including shifting in various directions within the cell, scaling to
the size of the cell, and (the default) simply enlarging it to fit.
Figure \ref{gridcellFit} illustrates annotations that can be
made to individual glyphs that define how they are made to
fit the cells they will inhabit. The data used here is
the same as earlier, save that (except in the first grid) the 4th cell is a label of the form
\Scala{s"cellfit(\$how)"} where \Scala{how} is one of the \Scala{CellFit.Method}
constants:

\begin{scala}
case object ShiftNorth     extends Method // ... to the top edge
case object ShiftNorthWest extends Method // ... to the top left corner
case object ShiftWest      extends Method // ... to the left edge ...
case object ShiftSouthWest extends Method // ... to the bottom left  ...
case object ShiftSouth     extends Method // ... to the bottom edge ...
case object ShiftSouthEast extends Method // ... to the bottom right ...
case object ShiftEast      extends Method // ... to the right edge ...
case object ShiftNorthEast extends Method // ... to the top right ...
case object Stretch        extends Method // scaled up to fit the cell
case object Enlarge        extends Method // centred in the cell
\end{scala}

In each case the grid is composed by:
\begin{scala}
Grid(fg = red(width=0), padx=10, pady=10).grid(width=3)(data)
\end{scala}

\PNGFIGURE[scale=0.35]{gridorder}{Tables made with \Scala{.grid(width = 1)(data)}
                                  and \Scala{.rows(width = 1)(data)}}


\PNGFIGURE[scale=0.5]{gridtable}{Table presentations of a grid}


\PNGFIGURE[scale=0.5]{gridcellFit}{Individual cell placement with \texttt{fitToCell}}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\SSS{OneOf: Temporal Alternations of Glyphs}
The \SCALA{OneOf} composition is used primarily in the implementation of
dynamically ``paged'' interfaces\footnote{Such as those provided in
the \Scala{Book()} API.} or in the presentation of
alternate captions on reactive glyphs.\footnote{Such
as those used in the \Scala{Checkbox} and \Scala{TextToggle} APIs}. It constructs a glyph whose appearance is chosen
dynamically from a palette of component glyphs.
Its bounding box is the union of the bounding boxes of its component glyphs;
and it shows only one of them at a time, namely the one selected most recently by  its \SCALA{select} method,
or by one of its \SCALA{next()} or \SCALA{prev()} methods.

Thus the definitions\footnote{See ``Glyphs are mutable'' (\ref {glyphsaremutable}) for an explanation
of why the label is defined as a function not just as a value.}
\begin{scala}
  def bananas = Label("Bananas", fg=white, bg=blue)
  val oneof: OneOf =
      OneOf(bg = Wide.red)( bananas.rotated(0)
                          , bananas.rotated(1)
                          , bananas.rotated(2)
                          , bananas.rotated(3)
                          )
 \end{scala}
gives rise to the glyph that is initially drawn as:
\begin{center}
\pdffig[scale=0.6]{PNG/oneof}
\end{center}

and after the execution of \SCALA{oneof.next()} is drawn as:
\begin{center}
\pdffig[scale=0.6]{PNG/oneofnext}
\end{center}

Subsequent invocations of \Scala{oneof.next()} will select successive components
for drawing, and an invocation of \Scala{oneof.select(n)} will select its $n$th (modulo 4)
component for drawing.\footnote{Only the currently selected component of a
\Scala{OneOf} is considered in the search for a reactive glyph to handle
a user gesture or keystroke. See Appendix \ref{thefocusprotocol} for details.} 

Had \SCALA{oneof} been specified without a background brush, then
the background would have been one of the backgrounds of its
maximal (by area) components.
\begin{center}
\pdffig[scale=0.6]{PNG/oneofnbg}
\end{center}


\clearpage
\SS{Brushes}
A brush applies ``paint'' to a surface. The
most important of its characteristics are its width (aka \SCALA{strokeWidth}), and
the colour of the paint it will apply. But it also has ``shape'', in the sense that
corners painted with it may be rounded, squared, mitered,
\textit{etc}; as well as having many other definable
characteristics, including a human-readable name.

For example, here are definitions of the \SCALA{blue} and \SCALA{red} brushes
used while preparing this paper.\footnote{Colour
is specified here by a 32-bit/4-byte integer -- usually written as a hexadecimal
constant. The first byte specifies its
\textit{alpha} -- which is analogous to opacity or covering power; the second, third, and fourth bytes
specify its red, green, and blue components.} 
\begin{scala}
  val blue = Brush("blue")(color=0xFF0000ff,  width=1.0f, cap=ROUND)
  val red  = Brush("red") (color=0xFFFF0000,  width=1.0f, cap=ROUND)
\end{scala}

and \SCALA{val Wide.blue} was defined as:
\begin{scala}
  Brush("Wide.blue")(color = 0xFF0000ff,
                     width = 15.0f,
                     cap   = SQUARE)
\end{scala}


The following two images show some brush properties in action. Notice the
rounded corners of the first rectangle, and that the points have
all the characteristics of the brushes they were drawn with.

\glyph[scale=0.6]{eg1d}

\glyph[scale=0.6]{eg1e}


In fact the library incorporates an embedded domain-specific language of brushes:
some expressions denote new brushes or variants of existing
brushes; and others denote commands that affect existing
brushes.\footnote{See appendix \ref{brushesaremutable} for an explanation
and examples of the latter.}
%
For example, the \SCALA{Wide.blue} brush could  have been defined
as a variant of \SCALA{blue}:

\begin{scala}

               blue(width=15.0f, name="Wide.Blue", cap=SQUARE)
\end{scala}

Brushes are  cheap to build, and it is straightforward to
define them \textit{ad-hoc} while building a glyph.\footnote{Implementation
details of the brush language may be of interest to the Scala
programmer who likes the idea of ``notationally sugared'' APIs.}

For example:
\begin{scala}
Row(align=Mid)(
   Point(Wide.blue(width=2*Wide.blue.strokeWidth, cap=BUTT)),
   Skip(2*Wide.blue.strokeWidth),
   Rect(150f, 100f, Brush("")(color=red.color,
                              width=Wide.blue.strokeWidth, cap=SQUARE)))
\end{scala}

denotes the glyph
\begin{center}
\PNGfig[scale=0.6]{eg1ex}
\end{center}




\newpage
\S{Glyph Transformers}

Glyph transformers are used to derive glyphs from simpler glyphs. Almost
all transformers are provided as intrinsic methods of all glyphs.
For example:

\glyph[scale=0.6]{eg1f}

\glyph[scale=0.6]{eg1g}

It's important to understand that, as a matter of policy, transforming a glyph, $g$
is an ``algebraic'' operation that denotes a tree in which $g$ is
embedded: it no more makes  a ``new'' copy of $g$ than
(for example) the successor $succ~n$ of a number $n$ makes a ``new'' copy of
$n$.\footnote{In light of the first prototype library implementing
glyphs mutably there is an argument against this policy because it
could lead to inadvertent sharing, with effects such as those
described in Appendix \ref{glyphsaremutable}. A future prototype is envisaged
in which glyphs are no longer mutable, and the policy will
be irrelevant.}


\begin{comment}
\begin{center}
\PNGfig[scale=0.6]{static}

\PNGfig[scale=0.6]{staticdown}
\end{center}
\end{comment}


Intrinsic glyph transformers include:

\begin{scala}
  def scaled(scale: Scale): Glyph 
  def enlarged(delta: Scalar, ...): Glyph 
  def enlargedTo(w: Scalar, h: Scalar, ...): Glyph 
  def enlargedBy(w: Scalar, h: Scalar, ...): Glyph 
  def rotated(quadrants: Int, ...): Glyph 
  def turned(degrees: Scalar, circular: Boolean, ...): Glyph 
  def skewed(skewX: Scalar, skewY: Scalar, ...): Glyph 
  def mirrored(leftRight: Boolean, topBottom: Boolean, ...): Glyph
\end{scala}
\begin{scala}
  def framed(fg: Brush = Glyphs.Framed.defaultFG,
             bg: Brush = Glyphs.Framed.defaultBG): Glyph
  def edged(fg: Brush = Glyphs.Framed.defaultFG,
            bg: Brush = Glyphs.Framed.defaultBG): Glyph
  def shaded(enlarge: Scalar = 0.25f,
             delta: Scalar = 8f,
             down: Boolean=false, ...): Glyph
  def beside(g: Glyph, align: VAlignment=Mid): Glyph 
  def above(g: Glyph, align: Alignment=Center): Glyph 
\end{scala}

In the above signatures, the abbreviation \SCALA{...} stands for the declaration that `fg` and `bg` parameters be inherited from
the glyph being transformed, unless otherwise specified. For example, the full signature of \SCALA{mirrored} is:
\begin{scala}

  def mirrored(leftRight: Boolean, topBottom: Boolean,
               fg: Brush = thisGlyph.fg,
               bg: Brush = thisGlyph.bg): Glyph    
\end{scala}

Figure \ref{intrinsics} shows a few more examples of their use:

\begin{figure}[t]
\label{intrinsics}

\PNGfig[scale=0.35]{eg1g}
\hfill
\PNGfig[scale=0.35]{eg1gskew}
\vskip1ex
\SCALA{g} \hfill \SCALA{g.skewed(0.5,0).framed()}
\vskip3ex

\PNGfig[scale=0.35]{eg1gskew2}
\hfill
\PNGfig[scale=0.35]{eg1gskew3}

\SCALA{g.skewed(-0.5, 0).framed()} \hfill \SCALA{g.skewed(-0.5, -0.5).framed()}


\begin{center}
\PNGfig[scale=0.35]{eg1gskew4}
\begin{scala}
g.skewed(0.5f, 0f).enlarged(27, bg=yellow(alpha=0.2f))
                  .framed(redFrame)
                  .turned(45f)
                  .mirrored(leftRight=true,topBottom = false)
                  .framed(fg=redFrame)
\end{scala}
\end{center}

\begin{center}
\PNGfig[scale=0.35]{eg1gskew5}
\SCALA{g.skewed(0.5f, 0.0f).framed().turned(30f).framed(fg=redFrame)}
\end{center}
\caption{Intrinsic glyph transformers in use}
\end{figure}

\clearpage



%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%



\S{Polygonal Glyphs}

\SS{Specification}
Polygons (open or closed) are specified by giving the coordinates
of the relevant vertices in addition to the diagonal of the bounding
box they will be drawn in.\footnote{A closed polygon is one whose last vertex is the same
as its first.}
They have several forms of constructor: all are features of
\SCALA{Polygon} or \SCALA{FilledPolygon}.
A \textit{rough} guide to deciding on what part of the bounding box
of a filled polygon gets filled is that a point is inside the polygon (therefore filled)
if a line from it to some arbitrarily chosen far away point
crosses one of the lines between adjacent vertices an odd number
of times; it is outside if the number is even.\footnote{The ``far away point'' should be
chosen so that the line is not parallel to one of the edges. This is rarely difficult.}

Compare the two red \SCALA{FilledPolygon}s with vertices respectively given by
\begin{scala}
FilledPolygon(200, 200, fg = red)((0,   0), (200, 200),
                                  (200, 0), (0,   200))

FilledPolygon(200, 200, fg = red)((200, 200), (0, 0),
                                  (200, 0),   (0, 200))
\end{scala}
\samples[scale=0.25]{lineSample3}{lineSample4}

Now compare the two blue \SCALA{FilledPolygon}s with vertices given by
\begin{scala}
FilledPolygon(100, 100, fg = blue)(
  (0,0), (20, 0), (20, 20), (40, 20), (40, 0),
  (60,0), (60, 60), (80, 60), (80, 0), (100,0))
  
FilledPolygon(100, 100, fg = blue)(
 ((100,0), (100, 100), (0, 100), (0,0),
  (20, 0), (20, 20), (40, 20), (40, 0),
  (60,0), (60, 60), (80, 60), (80, 0), (100,0))
\end{scala}
\samples[scale=0.7]{lineSample6}{lineSample7}

\begin{comment}
\pagebreak[3]
The corresponding non-filled \SCALA{Polygon}s are:

\samples[scale=0.8]{lineSample8}{lineSample9}
\end{comment}


%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%

\SS{Paint Effects}
Interesting effects are possible when paints are equipped with
path-effects, or are blurred.

\SSS{Path Effects}
Using brushes with path effects to draw frames can give aesthetically
interesting results. We provide intrinsic \Scala{Brush}-transforms for a
couple of these, namely:

\begin{scala}
  brush.sliced(segLength: Scalar, maxDisplacement: Scalar, ...): Brush
  brush.dashed(on_0, off_0, on_1, off_1, ...): Brush
\end{scala}

The former yields a brush whose paths are ``sliced'' into segments
of the specified length; segment endpoints are displaced from the
path by a random amount limited by the given maximum. If it appears,
the third integer paramater is the seed for the
generation of random numbers that determine the displacements.

The latter yields a brush that draws paths u

In the following sequence of examples we compute the
vertices of a 7-pointed regular star (a ``stargon''), then construct
a ``wobbly'' paintbrush (\SCALA{blueish}) that is used to render
the star: first  as a filled polygon then as an open polygon.


First we define generators for filled and non-filled stargon glyphs
of specific colours:

\begin{scala}
 def filledStargon(n: Int, fg: Brush): Glyph =
     FilledPolygon.$(256, 256, fg, nothing)(regularStarPath(n))                        
   
 def nonFilledStargon(n: Int, fg: Brush): Glyph =
     Polygon.$(256, 256, fg, nothing)(regularStarPath(n))                    
\end{scala}


Both use a generator for the vertices of the paths used by
the \SCALA{Polygon} constructors to make star glyphs: $R$ is the
length of edges of the star, with centroid at $(C,C)$.\footnote{Exercise: this
algorithm can be understood by thinking of the points on
the path as the successive places a tortoise will stop when
at each stage it moves by $R$ in the direction $heading$, then turns through
$theta$ -- stopping when it has made $n+1$ moves.
Find out what happens if $n$ is even, explain why, and suggest
an alternative termination condition that yields stargons of \textit{some} order for
$n\ge{}2$. }

\begin{scala}
def regularStarPath(n: Int): Seq[(Scalar, Scalar)] = {
    val C: Scalar = 128.0f
    val R: Scalar = 115f
    val star = new ArrayBuffer[(Scalar, Scalar)]
    val theta = PI - PI/n
    star += (((C + R, C)))
    for {i <- 0 until n} {
      val a = theta * i
      star += (((C + R * Math.cos(a)).toFloat, (C + R * Math.sin(a)).toFloat))
    }
    star += ((C + R, C))
    star.toSeq
  }
\end{scala}

Rendered straightforwardly with \SCALA{fg=blue} the filled and open stargons are:
\begin{center}
\pdffig[scale=0.3]{PNG/filledstar}
\quad\quad
\pdffig[scale=0.3]{PNG/openstar}
\end{center}


 The  \SCALA{blueish: Brush} is the same color as blue, but wider: it
 has "wobbly" edges specified by a path effect described by \Scala{sliced}.

\begin{scala}
  val blueish =
        blue(width = blue.strokeWidth*2).sliced(25.0f, 4.0f, 1)
\end{scala}

Rendered in blueish, the stargons are:
\begin{center}
\pdffig[scale=0.3]{PNG/filledstarw}
\quad\quad
\pdffig[scale=0.3]{PNG/openstarw}
\end{center}

All this works for stars of arbitrary odd arity:
here are  stars with $n=17, 11, 5, 3$:

\begin{center}
\pdffig[scale=0.3]{PNG/filledstarw17}
\pdffig[scale=0.3]{PNG/filledstarw11}
\pdffig[scale=0.3]{PNG/filledstarw5}
\pdffig[scale=0.3]{PNG/filledstarw3}
\end{center}

\begin{comment}
But for $n=4, 6, 8$, and other even numbers, the generator doesn't work:
\begin{center}
\pdffig[scale=0.3]{PNG/filledstarw4}
\pdffig[scale=0.3]{PNG/filledstarw6}
\pdffig[scale=0.3]{PNG/filledstarw8}
\end{center}

See if you can explain why the generator doesn't work, by guessing the $n$ used for these two stargons. The
open one uses a brush without a path effect.
\begin{center}
\pdffig[scale=0.3]{PNG/openstarw18}

\pdffig[scale=0.3]{PNG/filledstarw18}
\end{center}
\end{comment}



For example:

\begin{scala}
  Label("...").enlarged(20)
              .edged(fg = black(width = 2f).sliced(2.5f, 5f))
              .enlarged(10))
\end{scala}  
\begin{center}
\PNGfig[scale=0.7]{redframed}
\end{center}


It's easier to see the effect of the displacement limit when the path is a straight line. Here's
\begin{scala}
  Polygon(200, 200,
          fg = red(width = 4f, cap = ROUND).sliced(5f, 100f, 15)
  )((0, 100), (200, 100)).enlarged(4).framed())
\end{scala}

\begin{center}
\PNGfig[scale=0.5]{redpoly}
\end{center}

Another path effect leads to dashed/dotted lines. 
\begin{scala}
  Label("...").enlarged(20)
              .edged(fg = black(width = 2f).dashed(15f, 5f))
              .enlarged(10))
\end{scala}
\begin{center}
\PNGfig[scale=0.7]{dashframed}
\end{center}

Many other effects are available from
\textbf{Skia} \textit{via} \textbf{Skija}. 

\clearpage
\SSS{Blurred Paint Effects}
The intrinsic \Scala{Brush}-transformer \Scala{blurred} yields a
brush that blurs all the filled glyphs that it paints. When \Scala{brush: Brush}
\begin{scala}
   brush.blurred(blur: Scalar, dx: Scalar=0f, dy: Scalar=0f): Brush
\end{scala}

yields a blurred brush of the same colour as \Scala{brush}. When
used on \textit{filled} glyphs, it blurs their outline, and
can shift the blurred outline relative to their origin (by $(dx, dy)$).

Below we show the effects of painting a filled star with
\Scala{blue.blurred(24f)} and with \Scala{blue.blurred(48f, 20f, 20f)}.
Both ar \Scala{framed()}: notice that the latter is displaced by $(20, 20)$ within the
natural bounding box indicated by the frame.

\begin{center}
\pdffig[scale=0.5]{PNG/filledstarw5blur}
\quad\quad
\pdffig[scale=0.5]{PNG/filledstarw5blur20}
\end{center}



\SSS{Blurred Frame Effects}
Figure \ref{Etc-Blurred} shows the use of a blurred brush, as
well as uses of the extrinsic glyph transformer

\begin{scala}
   BlurredFrame(blur:Scalar,spread:Scalar,dx:Scalar=0f,dy:Scalar=0f, ...)
\end{scala}

The styled blurred button-framing specification 

\begin{scala}
   Decoration.Blurred(blur:Scalar,spread:Scalar,dx:Scalar=0f,dy:Scalar=0f, ...)
\end{scala}

is illustrated in Figure \ref{Styles-Blurred}.

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix
\S{Mutability of Glyphs and Brushes}
\SS{Glyphs are mutable}\label{glyphsaremutable}
In the present prototype implementation it is \textit{essential to understand that a glyph 
is mutable}: in particular that its \SCALA{location} and \SCALA{parent} features are changed as it is
incorporated in its glyph tree by its parent glyph.

This happens exactly once per glyph, and in order to use a glyph
more than once it necessary to copy it. Fortunately this is
straightforward: each form of glyph has a copy method that yields
a fresh\footnote{\textit{ie.} without having set
\textcolor{blue}{\textsf{location, parent}}.} structurally identical
(``deep'') copy. The copy method has \SCALA{fg, bg} arguments that
specify the foreground and background brushes of the copy; and these
are defaulted to those of the glyph being copied.

As a convenience, the \SCALA{Glyph} may be ``applied'' with the same result:
\begin{scala}
  def copy (fg: Brush=this.fg, bg: Brush=this.bg): Glyph
  def apply(fg: Brush=this.fg, bg: Brush=this.bg): Glyph =
      this.copy(fg, bg)
\end{scala}


When a glyph is used twice without copying, the results are rarely what was intended. For example,
here we show the outcome of using a glyph value a second time in a
tree without copying. When \Scala{egc} is defined by
\begin{scala}
   val egc: Glyph =
            Row.centered(Point(Wide.blue),
                         Skip(Wide.blue.strokeWidth),
                         Point(Wide.green),
                         Rect(150f, 100f, Wide.blue))
\end{scala}
it denotes a glyph drawn as
\begin{center}
\PNGfig[scale=0.55]{egc}
\end{center}
and the expression \Scala{Row(bg=white)(egc, egc)} denotes a glyph
drawn as
\begin{center}
\PNGfig[scale=0.55]{egc2}
\end{center}

What is happening is that \Scala{egc}'s location relative to its
parent in the glyph tree is set twice by the \SCALA{Row} compositor; and the second setting
is the one used during drawing.\footnote{That this can
occur \textit{without warning at compile time} is a defect in the design of the library to which there
are a multiplicity of potential solutions: we are considering them at the time of writing. But
for the moment we advise copying as a matter of course: it's not computationally very expensive.}

When the glyph is copied before both uses all is well:
\Scala{Row(egc(), egc())} is drawn as\footnote{In
fact if it's not going to be used again only one
copy is needed.}
\begin{center}
\PNGfig[scale=0.6]{egc1}
\end{center}


\SS{Brushes are mutable}\label{brushesaremutable}

In the present prototype implementation the attributes of brushes
can be changed dynamically, and the effects of these changes
\textit{apply retrospectively to every glyph that was ever drawn
with them}. Although this feature is not intended to be used frequently, it can occasionally
be useful: for example using a brush on part of a GUI that indicates
state by changing its colour.

Brushes have ``chained'' methods that can be used to change their
attributes; these  have the same names as the attributes, for
example:

\begin{scala}
          def strokeWidth(i: Float):    Brush = { ...; this }
          def color(i: Int):            Brush = { ...; this }       
          def cap(cap: PaintStrokeCap): Brush = { ...; this }
\end{scala}


For example, here's what \SCALA{eg1g} looks like in a context where the colour of the
wide blue \SCALA{Brush} has been changed retrospectively to yellow
by the command:

\begin{scala}
        Wide.blue.color(0xFFFFFF00)
\end{scala}

\begin{center}
\PNGfig[scale=0.6]{eg1gBlueToYellow}
\end{center}
The mutation methods return the glyph from
which they are invoked, so to change colour, width, and cap in the
same command one could write:

\begin{scala}
        Wide.blue.color(0xFFFFFF00).strokeWidth(50).cap(ROUND)
\end{scala}

or, recalling that \textsf{Scala} methods can also be used as infix operators, one could
have written:

\begin{scala}
        Wide.blue color 0xFFFFFF00 strokeWidth 50 cap ROUND
\end{scala}

It is probably unwise to change a stroke width dynamically in such a
way as to increase the size of a bounding box beyond its original
size, for that would invalidate an important assumption made during glyph
composition, namely that the sizes of component glyphs' bounding
boxes do not increase after composition.  This assumption is invalid
for glyphs such as those built by \Scala{.framed(...)} whose
bounding boxes are partly determined by the width of  brushes used
in them. Decreasing a stroke width dynamically does not violate
this assumption.

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%

\S{Text}
Here we discuss the low-level API for generating simple text glyphs. {The \textcolor{blue}{\textsf{Styled}}
package provides more versatile methods for composing glyphs that consist
of paragraphed text.}

A \SCALA{Text} is a glyph-builder, \textit{ie.} a \textit{factory}
for text glyphs. The function \SCALA{text}, defined below, constructs
a glyph-builder from the given string at the specified size in (the
italic Courier) \SCALA{typeFace}.

%\let\scalasize=\footnotesize
\begin{scala}
    val typeFace: Typeface =
          FontMgr.getDefault()
                 .matchFamilyStyle("Courier", FontStyle.ITALIC)

    def text(s: String, size: Float): Text =
          Text(s, new Font(face, size))
\end{scala}

The \SCALA{Text}s \SCALA{text1, text2} are glyph builders that will eventually
yield glyphs. The function \SCALA{em} defines an \textit{em}-width space.

\begin{scala}
    val text1 = text("Á 24pt Text", 24.0f)
    val text2 = text("A 12pt Text", 12.0f)
    def em    = Skip(font(12f).measureTextWidth("m"))
\end{scala}

\SCALA{Text}s provide the following methods that build glyphs:
\begin{scala}
   .asGlyph:    Glyph
   .atBaseline: Glyph
\end{scala}

Both yield glyphs with the same bounding box: but the second yields
a glyph that is expected to be drawn only within top-aligned
\SCALA{Row}'s.

\cglyph[scale=0.6]{text1}
\cglyph[scale=0.6]{text1a}

Drawing a sequence of \SCALA{atBaseline}-generated glyphs in a \textit{top-aligned} row positions them so that their
baselines coincide, and this is the intended effect.
\cglyph[scale=0.6]{textrow1}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
\SSS{Deprecated uses of \SCALA{asGlyph} and \SCALA{atBaseline} glyphs}
Using \SCALA{asGlyph}-generated glyphs of different sizes in rows is a cheap and nasty way
to simulate superscripts and subscripts and is not recommended for normal use.
\cglyph[scale=0.6]{textrow2}
\cglyph[scale=0.6]{textrow3}


When an \SCALA{atBaseline}-generated glyph does not have a \SCALA{Row} as parent, it
is drawn so that its baseline coincides with the top of its bounding rectangle: the result
is \textcolor{red}{never} useful. 
\begin{center}
\SCALA{text1.atBaseline(fg=blue).framed(grey)}

\PNGfig[scale=0.6]{text1b}
\end{center}
Moreover, when \SCALA{atBaseline}-generated glyphs of different heights are used in a bottom- or centre-aligned row the
results are \textcolor{red}{never} useful.
\begin{center}
\begin{scala}
    Row.centered(text1.atBaseline(fg=black),
                 text2.atBaseline(fg=blue)).framed(grey)}
\end{scala}
\PNGfig[scale=0.6]{textrow1a}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\S{The Focus Protocol}
\label{thefocusprotocol}
The windows of an application's GUI each have two foci: each
is either undefined or associated with a reactive glyph.


\begin{itemize}
   \item The  window's \Scala{keyboardFocus} is the reactive glyph that is
   expected to handle keyboard events within that window. Reactive glyphs
   usually co-operate to manage it.

   \item The window's \Scala{mouseFocus} is the reactive glyph that is
   expected to handle mouse events, such as those arising from movements,
   button presses and releases, and from mouse wheel events. Such
   events may also originate on a trackpad, touchscreen, \textit{etc}.
   
\end{itemize}

The (mouse) focus protocol is designed to ensure that events arising from
the manipulation of the mouse (or other pointing device) get directed
to an appropriate reactive glyph. The essence of the protocol is
described below. The specification of ``try to locate a
reactive glyph...'' is at \ref{locatingreactiveglyphs}.

\SS{MouseMove events}
  \begin{itemize}
    \item[(a)] If \Scala{mouseFocus} is defined, then
    \begin{itemize}
        \item[i] If the mouse location is within the focussed glyph, direct the
        event to that glyph.
        \item[ii] If mouse location is not within the focussed glyph, then direct a
        \Scala{GlyphLeave} event to that glyph, and set \Scala{mouseFocus} to \Scala{None}.
    \end{itemize}
    \item[(b)] If \Scala{mouseFocus} is not defined, then try to locate a reactive glyph
               that contains the mouse location.
              \begin{itemize}
                  \item[i] If there is such a reactive glyph, direct a \Scala{GlyphEnter}
                        event to it, and set \Scala{mouseFocus} to it.
                  \item[ii] If there is no such reactive glyph, ignore the event.
              \end{itemize}
  \end{itemize}

  
\SS{MouseButton events}
\begin{itemize}
    \item[(a)] If \Scala{mouseFocus} is defined, then
    \begin{itemize}
        \item[i] If the mouse location is within the focussed glyph, direct the
        event to that glyph.
        \item[ii] If mouse location is not within the focussed glyph, then
        just set \Scala{mouseFocus} to \Scala{None}.
    \end{itemize}
    \item[(b)] If \Scala{mouseFocus} is not defined, then try to locate a reactive glyph
               that contains the mouse location.
              \begin{itemize}
                  \item[i] If there is such a reactive glyph, direct a \Scala{GlyphEnter}
                        event to it, and set \Scala{mouseFocus} to it.
                  \item[ii] If there is no such reactive glyph, ignore the event.
              \end{itemize}
  \end{itemize}


\SS{MouseScroll events}
\begin{itemize}
    \item[(a)] If \Scala{mouseFocus} is defined, then direct the event to the focussed glyph.
    \item[(b)] If \Scala{mouseFocus} is not defined, then ignore the
               event.\footnote{\textbf{We are currently considering
               adding a third locus, namely \Scala{scrollFocus}.}}
\end{itemize}


 


In effect the protocol defined above means that a reactive glyph becomes ``aware'' that it has the focus
when the mouse moves into it; and becomes ``aware'' that it no longer has the focus
when the mouse moves out of it. Although it would be straightforward to change the
protocol so that fewer events are ignored, we believe that in many cases the
response of a glyph to an event ignored in the protocol would be to ... ignore it.


\SS{Locating Reactive Glyphs}\label{locatingreactiveglyphs}
Recall that the glyphs comprising a GUI all have their own
(0,0)-origin coordinate system, and that each glyph is located
relative to its parent in the glyph tree as its parent is being
laid out. This approach makes it straightforward to implement
geometric transforms on glyphs, such as the rotations, scalings, and
skewings described briefly earlier -- a transformed glyph is
displayed by applying the transform before displaying
the untransformed glyph. 

The search for a reactive glyph that contains a location is conducted
by first searching the glyph tree for the glyph
that most closely contains that location, then finding its nearest
reactive parent in the tree (usually, but not always, the same
glyph).

The search for the glyph that most closely contains a location is
conducted top-down in the glyph tree.  Composite glyphs that don't
themselves contain the location are not searched, but those that
do contain the location are searched for more specific components.
For the moment we consider that this algorithm is adequately
efficient, but if necessary glyph trees could be indexed
straightforwardly.


On the other hand, experience has shown that the algorithm
is not efficient enough to use during mouse motion to decide
whether the mouse location is still within the focussed glyph. This is
because mouse motion events are generated at high frequency as the
mouse traverses a window. So instead of using the algorithm, we
annotate each reactive glyph with the inverse of the (constant)
transform that was (last) used to display it, then use this
inverse to map the (absolute) mouse location back to the coordinate
system of the reactive glyph itself.

\SS{Locating  Glyphs in the presence of Overlays}
Menus and dialogues are managed by the module
\Scala{overlaydialogue.Dialogue} which provides a collection
(possibly empty) of \textit{overlays} per window: each of these is specified as a
glyph tree with a few additional properties.

The overlays  are organised as a stack of GUI ``layers''
drawn topmost-last: each appearing  on top of its predecessor in
the stack, and all appearing on top of the main GUI tree.
There is also a collection of named ``decorations'' that , each defined
by a glyph tree. These are drawn in no particular order after the
main GUI and the overlay stack. 

The algorithm to locate a glyph that contains the mouse is designed to find
a currently-visible glyph containing the mouse in:

\begin{enumerate}
\item[i] the topmost layer of the stack, or in
\item[ii] a decoration, or in
\item[iii] a currently-visible glyph in the application's main GUI tree.
\end{enumerate}

When the topmost layer of the stack is ``modal'' (\textit{ie} represents a menu
or a modal dialogue), then only (i) and (ii) above are considered.

The net effect is that glyphs in the main interface
that are \textit{completely hidden} by the topmost layer of the stack will not
be selected during a mouse-focus transfer. Normally, as far as a button
is concerned, if you can't see it \textit{all} then you can't press
it.\footnote{In the exceptional situation of \textit{loose hiding} being
enabled for the topmost overlay then if you can see some of a button then you can press it.}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\S{Anatomy of a Simple Reactive Glyph}

Here we give an account of the structure of the reactive glyph class
\Scala{ColouredButton}. The appearance of such buttons is specified
by a single glyph. The  foreground (or the background) colour of the glyph
changes when the mouse hovers over it, and when a button is
pressed (but not yet released) within it.If its \Scala{background}
flag is true, then it's the background colour of the button that is changed.

It inherits the features of a \Scala{GenericButton} that deal with
the details of mouse-motion and button-clicks. We shall discuss
these later: the main thing to understand now is that the state of
an active, non-disabled button is captured by:

\begin{scala}
    var hovered:  Boolean
    var pressed:  Boolean
\end{scala}

The former is true if and only if the (mouse) pointer is within the
button.\footnote{More precisely, the bounding
box of the glyph that represents the button on the screen.} The
latter is true if and only if the button has been pressed, but not
yet released, within the bounding box of the button. When a button is
released within the button, its \Scala{react} method is
invoked.\footnote{with a parameter, sometimes ignored, that captures the
current state of the keyboard modifiers, the exact button pressed, etc.}

A button can be programmatically disabled or made inactive:
\begin{scala}
    var disabled: Boolean
    var inactive: Boolean
\end{scala}

The first part of the definition is straightforward: the constructor
takes the glyph used to specify the button's appearance when neither
hovered nor pressed. The brushes \Scala{down} and \Scala{hover} specify
the foreground colour of the glyph when hovered and pressed, and when
just hovered. If the colour of the background is to be changed on
state changes, then \Scala{background} is set.

\begin{scala}
class ColourButton(
  appearance:     Glyph,
  down:           Brush,
  hover:          Brush,
  val background: Boolean, 
  val react:      Reaction) extends GenericButton {
  
  override def toString: String =
           s"ColourButton($up, $down, $hover, $background)"
\end{scala}

Because we cannot rely on the \Scala{fg} (\Scala{bg}) brush of the appearance
not being shared anywhere else in the GUI tree, we want to avoid
changing that brush. So we construct a \textit{copy} (\Scala{glyph})
of the appearance glyph, with \Scala{fg} (\Scala{bg}) set to \Scala{currentBrush}
-- a copy of the appearance's relevant brush. We intend to use
\Scala{glyph} when drawing the button; its  foreground (or background)  will
be painted using the copied brush, and the appropriate features of
that brush will be copied (from one of \Scala{up, down, hover})
according to the current state of the button.

\begin{scala}
   val up: Brush =
       if (background) appearance.bg else appearance.fg

   val currentBrush: Brush = up.copy()

   val glyph: Glyph        =
       if (background)
          appearance(bg=currentBrush)
       else
          appearance(fg=currentBrush)

   def setCurrentBrush(b: Brush): Unit = {
      currentFG.color(b.color).width(b.strokeWidth)
    }
\end{scala}

The \Scala{draw} method shows the current state of the
button by painting it with the appropriate brush using
the appropriate opacity (alpha).
It captures the current geometric transform that
will be used to render its glyph.\footnote{ The latter is used to
speed up the tracking of mouse movements. If the button is inactive or disabled,
it won't be used, but capturing it does no harm.}

\begin{scala}
    def draw(surface: Surface): Unit = {
        val (brush, alpha) = 
            if (disabled) (up, alphaDisabled) else
            if (inactive) (up, alphaUp) else
            (pressed, hovered) match {
              case (true, true)  => (down,  alphaDown)
              case (false, true) => (hover, alphaHover)
              case (_, _)        => (up,    alphaUp)
            }
        surface.withAlpha(diagonal, alpha) {
          setCurrentBrush(brush)
          glyph.draw(surface)
          surface.declareCurrentTransform(this)
       }
   }
\end{scala}

The following definitions
can be overridden if necessary, but have proven satisfactory in practice.

\begin{scala}
    def alphaDisabled: Int = 0x70;  def alphaUp:       Int = 0xFF
    def alphaDown:     Int = 0xFF;  def alphaHover:    Int = 0xF0
\end{scala}

The actual glyph that will be shown must be properly installed in the GUI
tree by making the button glyph its parent.

\begin{scala}
    locally { glyph.parent = this }
\end{scala}

The rest of the button glyph description is completely standard: it
implements the remaining glyph features by forwarding to
its ``embedded'' \Scala{glyph}.
\begin{scala}
    override def diagonal: Vec = glyph.diagonal

    override def glyphContaining(p: Vec): Option[Hit] =
                 glyph.glyphContaining(p)

    override def contains(p: Vec): Boolean =
                 glyph.contains(p)

    val fg: Brush = glyph.fg
    val bg: Brush = glyph.bg

    def copy(fg: Brush=this.fg, bg: Brush=this.bg): Glyph =
        new ColourButton(appearance(fg.copy(), bg.copy()), down, hover, react)

  }
\end{scala}

As usual we define a companion object to deliver methods
that support the convenient construction of useful \Scala{ColourButton}s.
The first one we show here provides a text-labelled button
using the various defaults provided by \Scala{Brushes}. The defaults
can be overridden at construction time.

\begin{scala}
object ColourButton {
 val up:    Brush = Brushes.buttonForeground()
 val down:  Brush = Brushes.buttonDown()
 val hover: Brush = Brushes.buttonHover()
 val bg:    Brush = Brushes.buttonBackground
 def apply(text:  String,
           up: Brush=up, down: Brush=down, hover: Brush=hover,
           bg: Brush=bg, background: Boolean = true)
          (react: Reaction): ReactiveGlyph =
 { val glyph: Glyph = Brushes.buttonText(text).asGlyph(up, bg)
   new ColourButton(glyph, down, hover, background, react)
 }

 def apply(glyph:Glyph,down:Brush,hover:Brush,background:Boolean)
          (react: Reaction): ReactiveGlyph =
     new ColourButton(glyph, down, hover, background, react)
}
\end{scala}
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\S{Examples}

The best way of getting to grips with \textbf{Glyph} is to study
the source of one or two of the medium-sized examples included with
it: particularly \Scala{DemonstrationNotebook}, and
\Scala{CalculatorExample}. The following few examples are considerably smaller,
and not particularly useful save as a getting-started guide. The use of
implicit style parameters in examples 3 and 4 means that the reader should be
somewhat familiar with the notion of implicits in Scala 2.

\SS{A Passive GUI}

This is an entirely passive application.
Its ``interface'' is an (unstyled) text label.
The abstract class \Scala{Application} provides the link between
the interface and the outside world, needing only a definition of
\Scala{GUI} to set up and populate its single main window.

\begin{scala}
package org.sufrin.glyph
package tests
import  Glyphs.Label

object Example1 extends Application  {
  val font = FontFamily("Courier").makeFont(size=32)
  val GUI: Glyph = Label("A simple label", font)
  override def title: String = "Example 1"
}
\end{scala}

On my computer, the text of the label seems a bit close to the
inner edge of the window: so our first modification to the
program will be to enlarge it all round by an uncoloured
rim of width 20\ux.\footnote{Distance measurements are
expressed in (possibly fractional) ``logical units'' (ux) -- these sometimes correspond
to the physical pixels on a screen, but on some high-resolution
screens a \textbf{ux} may correspond to more than one
pixel. \textbf{Glyph} manages the correspondence.} border around the label.
The colours and font of unstyled labels are given default values in
the definition of \Scala{Label}.

\begin{scala}

val GUI: Glyph = Label("A simple label", font).enlarged(20)
\end{scala}

\pagebreak[4]
The effect is discernible but not drastic.
\begin{center}
\pdffig[scale=0.5]{PNG/example1a}
\quad
\pdffig[scale=0.5]{PNG/example1b}
\end{center}

\SS{A GUI with explicitly-styled components}

This application's interface is defined as \Scala{GUI} 
in the trait \Scala{Example2Interface} that is mixed-in with
\Scala{Application} to form the main program.

\begin{scala}
package org.sufrin.glyph
package tests

import Glyphs.Rect
import NaturalSize.{Col, Row}
import ReactiveGlyphs.TextButton
import DefaultBrushes._
\end{scala}

\begin{scala}
trait Example2Interface { ... }

object Example2 extends Application  with Example2Interface {
  override def title: String = "Example 2"
}
\end{scala}

\begin{center}
\pdffig[scale=0.35]{PNG/example2a}
\end{center}

The interface is a centered column on a light grey background on
which there is a label separated by a transparent spacer
from a row of two captioned buttons: each edged using a
rounded blue brush. Interglyph spacing on the row is
10\ux.  The label's background is initially painted with
a rounded green brush; and the buttons
change its colour.

\begin{scala}
trait Example2Interface {
  val buttonFrame:     Brush = blue(cap=ROUND, width=18)
  val labelBackground: Brush = green().rounded(18)
  val font = FontFamily("Courier").makeFont(size=32)
  val spacer = Rect(0, 20, fg=nothing)

  import Glyphs.TextButton
  import Glyphs.Label

  val GUI: Glyph = Col(align=Center, bg=lightGrey) (
    Label("A simple label", font, fg=white, bg=labelBackground) enlarged(20),
    spacer,
    Row(skip=10)(
        TextButton("make it blue") {
           _ => labelBackground.color(blue.color)
        }.edged(buttonFrame),
        
        TextButton("make it red")  {
          _ => labelBackground.color(red.color)
        }.edged(buttonFrame)
    )
  ).enlarged(20)
}
\end{scala}

A \Scala{TextButton}'s default response to the mouse cursor entering
it is to turn its caption green; when the cursor is pressed in this
state the caption turns red, and if the cursor is released when the
caption is red, then the button's reaction method is invoked. Here,
each button's reaction changes the colour \Scala{labelBackground} that
was used to paint the label's background.

\begin{center}
\pdffig[scale=0.30]{PNG/example2b}
\pdffig[scale=0.30]{PNG/example2c}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\SS{A GUI with implicitly-styled components}

This application was derived from example 2, and has an almost
identical source code structure, except that the interface trait
\begin{enumerate}
\item leaves the detailed appearance (``styling'') of the
      components it uses to be specified implicitly by a
      \Scala{StyleSheet} named \Scala{style}
      which is to be determined later; and
\item imports its \Scala{Label} and \Scala{TextButton}
      components from the \Scala{styled} package, in which
      all components are defined with styling set. 
\end{enumerate}

\begin{scala}
package org.sufrin.glyph
package tests
import Glyphs.Rect
import NaturalSize.{Col, Row}
import DefaultBrushes._
\end{scala}

\begin{scala}
trait Example3Interface {
  implicit val style: StyleSheet
  import styled.TextButton
  import styled.Label

  def GUI: Glyph = Col(align=Center, bg=lightGrey) (
    Label("A simple label") enlarged(20),
    Rect(0, 20, fg=nothing),
    Row(skip=10)(
      TextButton("make it blue")
          { _ => style.labelBackgroundBrush.color(blue.color) },
      
      TextButton("make it red")
          { _ => style.labelBackgroundBrush.color(red.color) }
    )
  ).enlarged(20)
}
\end{scala}

Here the details of the appearance of the interface have been
abstracted into the single \textit{implicit } \Scala{style} value
-- whose definition has been delegated to a main program.\footnote{
Did you notice that the  \Scala{GUI: Glyph} is defined as as a
parameterless method?  Defining it as a \Scala{val} would lead
to the various components dependent on \Scala{style} starting to be evaluated
during the construction of an \Scala{Example3Interface} object
before \Scala{style} is materialized -- a subtle error
whose occurence depends on the order of construction of
the fields of \Scala{trait} instances. An alternative would be
to define it as a \Scala {lazy val}. The calculator example of \ref{calc} gives
a straightforward simple alternative to extending \Scala{Application} with
an interface trait.}

\begin{center}
\pdffig[scale=0.35]{PNG/example3a}
\end{center}

Our first main program defines \Scala{style} so that the
interface looks exactly the same as that of \Scala{Example2}.
This differs from the default style in only a few respects.
\begin{scala}
object Example3 extends Application with Example3Interface {

  implicit val style: StyleSheet = StyleSheet(
    labelBackgroundBrush  = labelBackground,
    labelForegroundBrush  = white,
    labelFontFamily       = FontFamily("Courier"),
    labelFontSize         = 32,
    buttonDecoration      = styles.decoration.Edged(buttonFrame)
  )
  
  override def title: String = "Example 3"
}
\end{scala}

Of course all styles deliver buttons (and other glyphs) with the
same functionality, so \textit{ the  visual style of an interface can
straightforwardly be decided upon separately from its functionality}.

The following appearances differ only insofar as their interfaces
were built with styles specifying different button appearances. 

\begin{center}
\pdffig[scale=0.35]{PNG/example3a}
\begin{scala}
    buttonBackgroundBrush = grey2,
    buttonForegroundBrush = black,
    buttonDecoration =
      styles.decoration.Framed( fg=darkGrey(cap=ROUND, width=6)
                              , bg=grey2
                              , radiusFactor = 0.3f)
\end{scala}

\pdffig[scale=0.32]{PNG/example3b}
\begin{scala}
  buttonForegroundBrush = red,
  buttonDecoration = styles.decoration.Blurred(fg=yellow, bg=nothing, 16, 5)
\end{scala}

\pdffig[scale=0.35]{PNG/example3c}
\begin{scala}
  buttonForegroundBrush = black,
  buttonDecoration = styles.decoration.Shaded(fg=darkGrey, bg=nothing, 16, 5)
\end{scala}
\end{center}


\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%


\SS{A Primitive Calculator}\label{calc}

Here we construct a (very) primitive calculator that
also uses styled components. The interface
is now defined as a class with a style parameter.
The text on its window is specified
in \Scala{glyphXML}, a notation reminiscent of (but different from
and incompatible with) HTML.\footnote{This time the interface is specified as
a class that takes a style sheet as a parameter, thereby avoiding the
need to defer construction of the GUI until the style materializes.}
\begin{center}
\pdffig[scale=0.30]{PNG/example4}
\end{center}


\begin{scala}
package org.sufrin.glyph
package tests
import  NaturalSize.{Col, Row}
import  styled.overlaydialogues.Dialogue.OK
import  styled._

object Example4 extends Application {
  val GUI: Glyph = new Example4Interface(StyleSheet()).GUI
  override def title: String = "Example4"
}

class Example4Interface(sheet: StyleSheet) {
  implicit val style: StyleSheet = sheet
  import glyphXML.Language._

  val help: Glyph =
    <div width="40em" align="justify">
      <p>
      This app solves the equation <i>c = a + b</i>
      if at least two of <i>a, b, c</i>
      are well-formed numbers: possibly floating-point.
      </p>
      <p>
        Typing <tt>↩</tt> (<i>ie. the enter key</i> in any of
        the text fields, causes the equation to be re-solved
        if possible.
      </p>
    </div>
\end{scala}

The interface embodies three text fields, all of which have the same
appearance and behaviour. When the \verb/Enter/ key is
pressed within them they invoke \Scala{calculemus()}}
if the text of the field looks like a number; otherwise they
pop up a dialogue objecting to it.

\begin{scala}
  val a, b, c = textField()
  val fields = List(a, b, c)
  
  def textField(): TextField = TextField(
     size = 8,
     onEnter = {
       case s: String if s.toDoubleOption.isDefined => calculemus()
       case s: String =>
         OK( objectTo(s) ).InFront(help).start()
     }
   )
  
   val GUI: Glyph = Col(align=Center)(
    help enlarged 25,
    Row.centered(c.framed(), TextLabel(" = "),
                 a.framed(), TextLabel(" + "), b.framed())
  ) enlarged(25)

  def calculenus(): Unit = ...
}
\end{scala}

The \Scala{calculemus()} method is the core of the application.
It tries to convert each of the text
fields into numbers, then calculates the
third if at least two are defined.


\begin{scala}
def calculemus(): Unit = 
 (c.text.toDoubleOption, a.text.toDoubleOption, b.text.toDoubleOption)
  match {
     case (None, Some(av), Some(bv)) => c.text = format(av+bv)
     case (Some(cv), Some(av), None) => b.text = format(cv-av)
     case (Some(cv), None, Some(bv)) => a.text = format(cv-bv)
     case (Some(cv), Some(av), Some(bv)) =>
          if (cv == av+bv) {} else c.format = text(av+bv)
     case _ =>
   }
   
def  format(d: Double): String = f"$d%.5g"
\end{scala}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
\S{What next?}
If you have found these example interfaces interesting and would like to
study one or two larger working examples that use many features
of \Glyph then \Scala{tests.demonstrationBook.Pages} is a
good place to start. 

The package \Scala{styled} defines a plethora of styled glyphs,
both reactive and passive; and the \Scala{styled.overlaydialogues}
and \Scala{styleded.windowdialogues} packages show how to use the
\Glyph's basic features to build popup dialogues and menus.

The package \Scala{glyphXML} was a latecomer to this party. It
integrates the \Scala{scala.xml}  notation embedded (in Scala 2)
with styles, and makes it fairly straightforward to mix styled
texts with glyphs in a way that may be helpful. It is
something of a work in progress, but has been used throughout much
of the code of \Scala{tests.demonstrationBook.Pages}.

The goal of using  GUIs is to control useful applications,
and, as well as the usual futures/promises machinery provided
in Java and Scala we have designed new ways of using \Glyph interfaces to
control applications that need not be running in the same thread or process
or even virtual machine as the interface itself. These depend
on channel-based communication, as implemented in our
\href{https://github.com/sufrin/microCSO}{microCSO}
DSL and its (somewhat more extensive) predecessor
\href{https://github.com/sufrin/ThreadCSO}{ThreadCSO}. The latter
provides cross-network communication straightforwardly through its
\Scala{.net} package.

In due course we will provide examples of using \Glyph with these DSLs
to build ``real'' application programs.



\S{Acknowledgements}
This work would not have been possible were it not for the
open source \href{https://skia.org/}{\textbf{Skia}},
\href{https://github.com/HumbleUI/HumbleUI}{\textbf{Skija}},
and \href{https://github.com/HumbleUI/JWM}{\textbf{JWM}} projects.

I am grateful to Sasha Walker\Footnote{$*$}{Of Magdalen College,
and the Department of Computer Science, Oxford University},
for her patience in waiting for me to develop the initial working prototype of this
library, and for her tolerance when listening to explanations of my implementation
of the focus protocol. 

Dominic Catizone\Footnotemark{$*$} made a remark that helped me solve a
problem with designing the geometry of (non-quadrant) rotations of bounding boxes.
\end{document}

\clearpage
\S{Pages from {DemonstrationNotebook}}

Figures \ref{Help} to \ref{Etc-Split} show some of the pages
of the \texttt{DemonstrationNotebook} example. They are intended to
illustrate some of the available tools in use, and their source
code shows how the tools can be used.

The  (top-level) notebook is structured as
a sequence of pages with titles. Pages may themselves
have nested notebooks, as exemplified by the
\Scala{"Etc*"} page below.

The \Scala{Layout} feature of a notebook supports methods, such as
\Scala{rightButtons}, \Scala{leftButtons}, ... whose invocation
yields a GUI with buttons juxtaposed to a \Scala{OneOf} that has
a glyph for each defined page.


\begin{scala}
trait DemonstrationPages
     ...
     
     val noteBook = new NoteBook
     val Page = noteBook.DefinePage
     
       Page("Help", "Help for the Demonstration Notebook") {...}
       Page("New", "Make a new or cloned GUI ") {...} 
       Page("Menus*", "Window menus and dialogues") {...}
       Page("Transforms*", "") {...}
       Page("Overlays*", "Features implemented as ...") {...}
       Page("Framing*", "") {...}
       Page("Styles*", "") {...}
       Page("Events*", "") {...}
       Page("Fonts*", "..") {...} (HelpStyle.labelStyle)
       Page("Etc*", "") {
        val nested = new Notebook {}
        val Page = nested.DefinePage
        Page("Animation", "") {...}
        Page("Grid", "buts = 8 ... ") {...}
        Page("Blurred", "") {...}
        Page("Split", "") {...}
        Page("Scroll", "Scrolling and Scaling with ViewPort") {...}
        Page("OneOf", "OneOf backgrounds") {...}
        Page("Sliders", "") {...}
        Page("CheckBox", "Toggles and Checkboxes") {...}
        Page("Fonts", "") {...}
        nested.Layout.rightButtons()
      }
      
      ...
\end{scala}

\clearpage
Each of the lazy values defined
below is bound to one particular notebook layout; and the
top-level application logic chooses one of them as the GUI
for the application. Figure \ref{Framing-Text1 |Skewed Tabs|} illustrates
the ``skewed buttons'' presentation style.
\begin{scala}
     ...
     lazy val asRNotebook = noteBook.Layout.rightButtons()
     lazy val asLNotebook = noteBook.Layout.leftButtons()
     lazy val asVNotebook = noteBook.Layout.rotatedButtons(3)
     lazy val asSNotebook = noteBook.Layout.skewedButtons(0.2f, 0f)
     lazy val asTNotebook =noteBook.Layout.topButtons()
     
} // end DemonstrationPages
\end{scala}

The application as a whole is an instance of the Glyph \Scala{Application} trait --
that provides definitions of \Scala{GUI}, \Scala{Title}, \textit{etc.}
Importantly the standard \Scala{onClose} method invokes a method that
pops up a dialogue that asks for confirmation when the application window is closed.

\begin{scala}
object DemonstrationNotebook extends DemonstrationPages with Application {
  lazy val GUI =
       if (extraArgs contains "-notebook")   asRNotebook else
       if (extraArgs contains "-rnotebook")  asRNotebook else
       if (extraArgs contains "-lnotebook")  asLNotebook else
       if (extraArgs contains "-snotebook")  asSNotebook else
       if (extraArgs contains "-vnotebook")  asVNotebook else
       if (extraArgs contains "-tnotebook")  asTNotebook else
       if (extraArgs contains "-menu") asMenu else asRNotebook

  def title =
      s"""SmallTest -scale=$scaleFactor ${extraArgs.mkString(", ")}"""

  override
  val defaultIconPath: Option[String] = Some ("./flag.png")

  override
  def onClose(window: Window): Unit = confirmCloseOn(GUI)(window)
}
\end{scala}


\begin{comment}
\begin{scala}
  def confirmCloseOn(glyph: Glyph)(window: Window): Unit = {
    import windowdialogues.Dialogue.OKNO
    val prompt =
      Row.centered(PolygonLibrary.closeButtonGlyph scaled 5 enlarged(50),
                   TextLabel("Do you want to Exit?")(HugeLabelStyle) scaled 0.7f
                ).enlarged(50)
    OKNO(prompt,
         title="Exit Dialogue", ok=" Exit now ", no=" Continue ").InFront(glyph).andThen{
            case close => if (close) window.close()
         }
  }
\end{scala}
\end{comment}
\newpage
\clearpage
\SAVEDFIG Help/the Help page/
\SAVEDFIG New/the New page/
\SAVEDFIG Menus-Dialogues/the Dialogues subpage of Menus* /
\SAVEDFIG Transforms-Turn/the Turn subpage of Transforms* /
\SAVEDFIG Transforms-Tight/the Tight subpage of Transforms* /
\SAVEDFIG Transforms-Skew/the Skew subpage of Transforms* /
\SAVEDFIG Transforms-Mirror/the Mirror subpage of Transforms* /
\SAVEDFIG Overlays-Annotation/the Annotation subpage of Overlays* /
\SAVEDFIG Overlays-Dialogues/the Dialogues subpage of Overlays* (vertical tabs notebook)/
\SAVEDFIG Overlays-Dialogues-PoppedUp/a Popped-up dialogue (vertical tabs notebook) /
\SAVEDFIG Framing-Text1 |Skewed Tabs|/the Text1 subpage of Framing* (skewed tabs notebook) /
\SAVEDFIG Framing-Text2/the Text2 subpage of Framing* /
\SAVEDFIG Framing-Framed/the Framed subpage of Framing* /
\SAVEDFIG Framing-Edged/the Edged subpage of Framing* /
\SAVEDFIG Styles-Framed/the Framed subpage of Styles* /
\SAVEDFIG Styles-Blurred/the Blurred subpage of Styles* /
\SAVEDFIG Events-Events/the Events subpage of Events* /
\SAVEDFIG Etc-Animation/the Animation subpage of Etc* (mid-animation) /
\SAVEDFIG Etc-Grid-RowsCols/the Rows{/}Cols subpage of Etc*.Grid /
\SAVEDFIG Etc-Grid-CellSizes/the Cell Sizes subpage of Etc*.Grid /
\SAVEDFIG Etc-Grid-GlyphPlacement/the Glyph Placement subpage of Etc*.Grid /
\SAVEDFIG Etc-Blurred/the Blurred subpage of Etc* /
\SAVEDFIG Etc-Split/the Split subpage of Etc* /
\clearpage


\end{document}

