package org.sufrin.glyph

import io.github.humbleui.jwm.{Event, Window}

import java.util.function.Consumer

/** Synthetic events are generated as the mouse moves between (reactive) glyphs  */
class GlyphEvent extends Event
/** Synthetic event generated as the mouse leaves the currently-mouseFocus active glyph */
case class GlyphLeave(leaving: Option[ReactiveGlyph], entering: Option[ReactiveGlyph], modifiers: Int) extends GlyphEvent
/** Synthetic event generated as the mouse enters a new active glyph */
case class GlyphEnter(leaving: Option[ReactiveGlyph], entering: Option[ReactiveGlyph], modifiers: Int) extends GlyphEvent

/** Synthetic events generated only for `RootGlyphs`s */
class RootGlyphEvent extends Event
/** Synthetic Event */
case class RootEnterEvent(window: Window) extends RootGlyphEvent
/** Synthetic Event */
case class RootLeaveEvent(window: Window) extends RootGlyphEvent


/**
 *   An `EventHandler` is the bridge between `jwm` events generated by `Window`s,
 *   and the actions of `ReactiveGlyph`s.
 *
 */
trait EventHandler extends Consumer[Event] {

  thisHandler =>

  import GlyphTypes.Pixels

  import io.github.humbleui.jwm.{EventKey, EventMouseMove, EventMouseScroll, EventTextInput, EventTextInputMarked, Screen}

  /** the window for which this handler is handling events */
  val window: Window
  /** the root of the glyph tree that defines the GUI for this window */
  val root:   Glyph
  /**  the `Screen` associated with `window` */
  val screen: Screen

  /**
   *   Implement mousewheel scrolling/scaling for the whole GUI if
   *   overridden as true.
   */
  val scrollWholeWindow: Boolean = false
  /** The current hardwareScale factor for the whole window */
  var softwareScale = 1.0f
  /** The current pan- and tilt- factors for the whole window. */
  var panFactor, tiltFactor = 0.0f

  /** Log events as they are accepted */
  var logEvents: Boolean = false
  var logLn: String => Unit = { line  => println(line) }
  var logEv: (Event, Modifiers.Bitmap) => Unit = {
      case (event, modifiers) =>
        if (modifiers.any) logLn(s"$event\n\t$modifiers") else logLn(s"$event")
  }

  /**
   *   Scroll/hardwareScale the entire window
   *
   *   This is method is intended largely to be used when
   *   debugging glyph layouts that might be incorrect, or too large.
   */
  def scrollWindow(scroll: EventMouseScroll): Unit = {
     import io.github.humbleui.jwm.KeyModifier
     if (scroll.isModifierDown(KeyModifier.SHIFT)) { // magnification
       val delta = if (scroll._deltaX+scroll._deltaY > 0) 1.2f else 1 / 1.2f
       softwareScale *= delta
     } else
     if (scroll.isModifierDown(KeyModifier.CONTROL)) { // panning
         panFactor += scroll._deltaY
     } else { // tilting
         tiltFactor += scroll._deltaY
     }
     window.requestFrame()
  }

  // state of the hover/focus machine
  /**
   *  When `mouseFocus.isDefined` the cursor is hovering over or in that glyph,
   *  and this handler is directing mouse and wheel events to it
   */
  var mouseFocus:         Option[ReactiveGlyph] = None
  /**
   * The glyph that was most recently focussed. Support for off-glyph button click
   */
  var recentMouseFocus:   Option[ReactiveGlyph] = None

  /**
   *  When `keyboardFocus.isDefined` this handler is directing all keystrokes to that glyph.
   *
   *  Otherwise this handler handles `EventKey`s (and no others) with its own `onKeyboardUnfocussed`
   */
  var keyboardFocus:  Option[ReactiveGlyph] = None

  /**
   *  The last value of `keyboardFocus` as that focus drifted away from a ReactiveGlyph.
   *  If it's `Some(g)`, then keyboard events are offered to `g` when  `keyboardFocus` is `None`.
   *  NOTE: this originated (on MacOS) to support external "viewer" widgets that never take application focus
   *  sending key events to the current application. Examples of these are
   *  the emoji and symbol viewer, and the keyboard viewer.
   */
  var recentKeyboardFocus:  Option[ReactiveGlyph] = None

  def giveupFocus(): Unit = {
    giveupMouseFocus()
    giveupKeyboardFocus()
  }

  def giveupMouseFocus(): Unit = {
    recentMouseFocus = mouseFocus
    mouseFocus = None
  }

  def giveupKeyboardFocus(): Unit = {
    recentKeyboardFocus = keyboardFocus
    keyboardFocus = None
  }

  def offGlyphClick(): Unit = {
    // tell the root glyph there has been an off-glyph keyboard click
    root match {
      case glyph: RootGlyph =>
           glyph.offGlyphClick()
      case _ =>
    }
  }

  /** Invoked on an `EventKey` when there's no `keyboardFocus` */
  def onKeyboardUnfocussed(key: EventKey): Unit = {}
  /** Invoked on an `EventTextInput` when there's no `keyboardFocus` */
  def onKeyboardUnfocussed(key: EventTextInput): Unit = {}
  /** Invoked on an `EventTextInputMarked` when there's no `keyboardFocus` */
  def onKeyboardUnfocussed(key: EventTextInputMarked): Unit = {}

  import GlyphTypes.Scalar
  /*
   * The screen-resolution-dependent hardwareScale factor: larger for higher-resolution screens
   */
  def hardwareScale: Scalar = screen.getScale

  /**
   * Maps a reported mouse position (in pixels) to a logical view position
   */
  @inline def mouseLocation(mouseX: Int, mouseY: Int): Vec = Vec((mouseX / hardwareScale) / softwareScale - panFactor, (mouseY /hardwareScale) / softwareScale - tiltFactor)

  def contentLocation: (Int, Int) = {
    val ca = window.getContentRectAbsolute
    (ca.getLeft, ca.getTop)
  }

  def effectiveScale: Scalar = hardwareScale*softwareScale

  def onScreenSize(size: Vec): Pixels = ((size.x*effectiveScale).toInt, (size.y*effectiveScale).toInt)
  def onScreenSize(g: Glyph): Pixels   = onScreenSize(g.diagonal)

  def logicalLocation(x: Scalar, y: Scalar): (Int, Int) = (x.toInt, y.toInt)
  def logicalLocation(loc: Vec): (Int, Int) = logicalLocation(loc.x, loc.y)


  def accept(e: Event): Unit = {
    import Modifiers._

    import io.github.humbleui.jwm._
    import io.github.humbleui.jwm.skija.EventFrameSkija;

    if (logEvents) { logEv(e, Modifiers(e)) }

    e match {
      // TODO: integrate with Interaction
      case wc: EventWindowClose =>
        if (App._windows.size == 0) {
          // Terminate when the last window closes
          App.terminate()
        }

      // TODO: integrate with Interaction.
      // This means that the close button on the window frame has been pressed; maybe
      // some "do you mean it?" type prompts need to be made.
      // on MacOS cmd-Q just kills the running app.
      case closeEvent: EventWindowCloseRequest =>
           root match {
             case root: RootGlyph =>
               root.windowCloseRequest(window)
               root.reDraw()
             case _ =>
           }

      // This event is invoked by/after a `window.requestFrame`
      case frame: EventFrameSkija =>
        val surface = frame.getSurface
        //println(s"Scalefactor = $softwareScale grid{screen.getScale}")
        val canvas = Surface(surface.getCanvas.resetMatrix().scale(screen.getScale*softwareScale, screen.getScale*softwareScale).translate(panFactor, tiltFactor), hardwareScale*softwareScale)
        canvas.clear(0xffeeeeee) // TODO: make this (background) settable
        root.draw(canvas)

      case key: EventKey     =>           // key pressed or released
        keyboardFocus match {
          case None =>
              recentKeyboardFocus match {
                case None => onKeyboardUnfocussed(key)
                case Some(glyph) =>
                  glyph.accept(key, Vec.Origin, window)
              }
          case Some(glyph) => glyph.accept(key, Vec.Origin, window)
        }

      case key: EventTextInput  =>        // key pressed that yielded some textlayout
        keyboardFocus match {
          case None =>
               recentKeyboardFocus match {
                 case None => onKeyboardUnfocussed(key)
                 case Some(glyph) =>
                      glyph.accept(key, Vec.Origin, window)
               }
          case Some(glyph) => glyph.accept(key, Vec.Origin, window)
        }

      case key: EventTextInputMarked =>   // Diacritical pressed
        keyboardFocus match {
          case None => recentKeyboardFocus match {
            case None => onKeyboardUnfocussed(key)
            case Some(glyph) =>
              glyph.accept(key, Vec.Origin, window)
          }
          case Some(glyph) => glyph.accept(key, Vec.Origin, window)
        }

      case scroll: EventMouseScroll =>
        // Offer it to the currently-mouseFocus glyph, if there is one
        // or have it work on the entire Window (if that is enabled)
        mouseFocus match {
          case Some(theGlyph: ReactiveGlyph) =>
            val mouseLoc = mouseLocation(scroll.getX, scroll.getY)
            theGlyph.accept(scroll, theGlyph.glyphLocation(mouseLoc), window)
          case None =>
            if (scrollWholeWindow) scrollWindow(scroll)
        }

      case mouse: EventMouseButton =>
        val mouseLoc = mouseLocation(mouse.getX, mouse.getY)
        mouseFocus match {
          case Some(glyph) =>
            if (glyph.contains(mouseLoc)) {
              //print(s"B ")
              glyph.accept(mouse, glyph.glyphLocation(mouseLoc)/*mouseLoc - glyph.rootDistance*/, window)
              if (glyph.stateChanged)  window.requestFrame()
            } else {
              giveupMouseFocus()
              window.requestFrame()
            }

          case None =>
            // mouse wasn't focussed: maybe we have focussed on a new glyph
            root.glyphContaining(mouseLoc) match  {
              case None =>
                // No glyph contains the event
                if (!mouse.isPressed) {
                  //recentMouseFocus.get.accept(GlyphPostFocusRelease(None, None), mouseLoc, window)
                  offGlyphClick()
                }
              // glyph contained the event
              case Some(Hit(glyph, location)) =>
                    glyph.reactiveParent match {
                      // no REACTIVE glyph contains the event
                      case None =>
                        if (!mouse.isPressed) {
                          //recentMouseFocus.get.accept(GlyphPostFocusRelease(None, None), mouseLoc - glyph.rootDistance, window)
                          offGlyphClick()
                        }
                        window.requestFrame()

                      // a reactive glyph contains the event: refocus
                      case focussed =>
                        recentMouseFocus = focussed
                        mouseFocus = focussed
                        val theGlyph = focussed.get
                        theGlyph.accept(GlyphEnter(recentMouseFocus, mouseFocus, Modifiers(mouse)),
                          theGlyph.glyphLocation(mouseLoc) /*mouseLoc - theGlyph.rootDistance*/,
                          window)
                        if (theGlyph.stateChanged) window.requestFrame()
                    }
                  }
      }

      case mouse: EventMouseMove =>
        // MouseStateTracker.discover(root.asInstanceOf[RootGlyph], mouse, window) // obsolescent
        val mouseLoc = mouseLocation(mouse.getX, mouse.getY)
        root.asInstanceOf[RootGlyph].onMotion(mouseLoc, mouse)
        // println(s"$mouseLoc (scaled $scaleFactor) #grid{screen.getScale} $mouse")
        mouseFocus match {
          case Some(focussed) =>
            if (focussed.contains(mouseLoc)) {
              focussed.accept(mouse, focussed.glyphLocation(mouseLoc)/*mouseLoc - focussed.rootDistance*/, window)
              if (focussed.stateChanged) window.requestFrame()
            } else {
              import io.github.humbleui.jwm.MouseCursor
              // it has left the focussed glyph
              focussed.accept(GlyphLeave(mouseFocus, None, Modifiers(mouse)),
                focussed.glyphLocation(mouseLoc), //mouseLoc - focussed.rootDistance,
                window)
              giveupMouseFocus()
              window.setMouseCursor(MouseCursor.ARROW)
              if (focussed.stateChanged) window.requestFrame()
            }

          case None =>
            // maybe we have a new hover; maybe the mouse is entering or leaving the window itself
            for { Hit(glyph, loc) <- root.glyphContaining(mouseLoc)} {
              glyph.reactiveParent match {
                case None =>
                //println(s"No reactive parent for $glyph")

                case reactive =>
                  recentMouseFocus = mouseFocus
                  mouseFocus = reactive
                  reactive.get.accept(GlyphEnter(recentMouseFocus, mouseFocus, Modifiers(mouse)), mouseLoc - reactive.get.rootDistance, window)
              }
            }
            window.requestFrame()
        }

     case _: EventFrame =>

     case other =>
        root match {
          case glyph: RootGlyph => glyph.acceptWindowEvent(other, window, this)
          case _ =>
            window.requestFrame() // **
         }
    }
  }


}
