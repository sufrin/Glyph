package org.sufrin.glyph

import GlyphTypes.FontStyle.ITALIC
import NaturalSize.Col
import TestFiles.fileSystem
import styled.ToggleVariable

import java.nio.file._
import java.nio.file.attribute._
import java.nio.file.Files.readAttributes
import java.util.Comparator
import scala.collection.mutable
import scala.jdk.CollectionConverters._



object System {
  lazy val fileStores: Iterable[FileStore] = FileSystems.getDefault.getFileStores.asScala
  lazy val rootDirs:   Iterable[Path] = FileSystems.getDefault.getRootDirectories.asScala
  lazy val supported:  mutable.Set[String] = FileSystems.getDefault.supportedFileAttributeViews.asScala
}

/**
 * A cache for a value
 * @param generate function to generate the value
 * @tparam T the type of the value
 */
class Cache[T]( generate: ()=>T ) {
  private var current: Option[T] = None
  /** Is the cache currently valid? */
  def isValid: Boolean = current.nonEmpty
  /** The currently cached value; regenerated if necessary. */
  def value: T = current match {
    case None =>
      val t = generate()
      current = Some(t)
      t
    case Some(t) => t
  }
  /** Invalidate the cached value: the next `value` will regenerate the cached value*/
  def invalidate(): Unit = current = None
}


object Cache {
  /**
   * A `Cache[T]` (re-)generated by `generate`
   */
  def apply[T](generate:  => T): Cache[T] = new Cache(() => generate)
}

/**
 *  Proxy for the directory/folder at `path`.
 */
class Folder(val path: Path) {
  import java.nio.file.Files.{list, readAttributes}
  private val byName = new Comparator[Path] { def compare(o1: Path, o2: Path): Int = o1.toString.compareToIgnoreCase(o2.toString) }

  lazy val sortedPaths: Cache[Seq[Path]] = Cache[Seq[Path]]{
      require (path.toFile.isDirectory, s"$path is not a directory")
      val stream = list(path).sorted(byName)
      stream.iterator().asScala.toSeq
  }

  lazy val dirs: Cache[Seq[Path]] = Cache {
    sortedPaths.value.filter(_.toFile.isDirectory)
  }

  lazy val notDirs: Cache[Seq[Path]] = Cache {
    sortedPaths.value.filterNot(_.toFile.isDirectory)
  }

  lazy val splitDirs: Cache[(Seq[Path], Seq[Path])] = {
   val paths = sortedPaths
   val dirs, nonDirs = new collection.mutable.ArrayBuffer[Path]
   for { path <- sortedPaths.value }
     (if (path.toFile.isDirectory) dirs else nonDirs).addOne(path)
    Cache(dirs.toSeq, nonDirs.toSeq)
  }

  def readPosixAttributes(path: Path): PosixFileAttributes = readAttributes(path, classOf[PosixFileAttributes], LinkOption.NOFOLLOW_LINKS)

  def attributes(paths: Seq[Path]): Seq[(Path, PosixFileAttributes)] = {
    paths.map { path => (path.getFileName, readPosixAttributes(path))}
  }

  /**
   * A mapping from the filenames in this folder to their posix attributes. This
   * mapping is kept up-to-date incrementally whenever `validate()` is invoked.
   */
  lazy val attributeMap: Cache[mutable.LinkedHashMap[Path,PosixFileAttributes]] = Cache {
    val attrs = attributes(sortedPaths.value)
    val map = new mutable.LinkedHashMap[Path,PosixFileAttributes]
    for (entry <- attrs) map.addOne(entry)
    map
  }

  /**
   * Invalidate all caches except the `attributeMap`.
   */
  def invalidate(): Unit = {
    for { cache <- List(splitDirs, dirs, notDirs, sortedPaths) } cache.invalidate()
  }

  def withValidCaches[T](expression: => T): Unit = {
    validate()
    expression
  }


  /**
   *  When anything happens to this directory we invalidate all the (rarely-used)
   *  sequence caches as a whole; and we update the `attributeMap` incrementally.
   */
  private val watching = java.nio.file.FileSystems.getDefault.newWatchService()
  locally {
    import StandardWatchEventKinds._
    path.register(watching,ENTRY_CREATE,ENTRY_DELETE,ENTRY_MODIFY,OVERFLOW)
  }

  private def validate(): Unit = {
    val watchKey = watching.poll
    if (watchKey ne null) {
      var changes, overflow = false
      for { event <- watchKey.pollEvents.asScala } {
        import StandardWatchEventKinds._
        val changedKey = event.context.asInstanceOf[Path]
        val changedPath = path.resolve(changedKey)
        println(s"${event.kind} ${event.context} $changedPath")
        try {
          event.kind match {
            case ENTRY_CREATE =>
              attributeMap.value.update(changedKey, readPosixAttributes(changedPath))
            case ENTRY_MODIFY =>
              attributeMap.value.update(changedKey, readPosixAttributes(changedPath))
            case ENTRY_DELETE =>
              attributeMap.value.remove(changedKey)
            case OVERFLOW =>
              overflow = true
          }
          changes=true
        } catch {
          case exn: NoSuchFileException =>
          // a deletion has followed a create or a modify since the last
          // time validate was invoked so there are no attributes to read
          // from the filestore when we try to act on the preceding create/modify
          // events.
        }
      }
      watchKey.reset()
      if (changes) {
        invalidate()
        if (overflow) attributeMap.invalidate()
      }
    }
  }

}

object FileAttributes {
  implicit class legibleAttributes(attrs: PosixFileAttributes) {
    def lastModifiedTime: FileTime = attrs.lastModifiedTime()
    def lastAccessTime: FileTime = attrs.lastAccessTime()
    def creationTime: FileTime = attrs.creationTime()
    def owner: UserPrincipal = attrs.owner()
    def group: GroupPrincipal = attrs.group()
    def permissions: collection.mutable.Set[PosixFilePermission] = attrs.permissions().asScala
    def mode: String = PosixFilePermissions.toString(attrs.permissions)
    def isDirectory: Boolean = attrs.isDirectory
    def isSymbolicLink: Boolean = attrs.isSymbolicLink
    def size: Long = attrs.size
    lazy private val d = if (isDirectory) "d" else "-"
    lazy private val s = if (isSymbolicLink) "@" else " "
    def dmode: String = s"$d$mode$s"
    def asString: String = s"$dmode $owner.$group $size $creationTime $lastModifiedTime $lastAccessTime"
  }

}


class Explorer(folder: Folder)(val dirSheet: StyleSheet, val fileSheet: StyleSheet)  {
  import styled.TextButton
  val (dirs, files) = folder.splitDirs.value

  val selected = mutable.LinkedHashMap[Path, ToggleVariable]()
  locally {
    for { path <- dirs ++ files } selected(path) = ToggleVariable(false){ _ => onSelectionChanged() }
  }

  def onSelectionChanged(): Unit = {
    println(selection.toSeq.mkString("\n"))
    println("---")
  }

  def selection: mutable.Iterable[Path] = for {(path, sel) <- selected if sel.value } yield path

  val dirButtons: Seq[Glyph] =
      for  { path <- dirs if Visible(path) } yield {
        val selector = styled.CheckBox(false)(selected(path))(fileSheet)
        val button = TextButton(path.getFileName.toString){
          _ =>
            val folder = new Folder(path)
            styled.windowdialogues.Dialogue.FLASH(new Explorer(folder)(dirSheet, fileSheet).GUI, title=path.toString)(dirSheet).OnRootOf(GUI).start()
        }(dirSheet)
        NaturalSize.Row(align=Mid)(selector, button)
      }

  def Invisible(path: Path): Boolean = path.getFileName.toString.charAt(0)=='.'
  def Visible(path: Path): Boolean = path.getFileName.toString.charAt(0)!='.'

  val fileButtons: Seq[Glyph] =
      for  { path <- files if Visible(path) } yield {
        val selector = styled.CheckBox(false)(selected(path))(fileSheet)
        NaturalSize.Row(align=Mid)(selector, TextButton(path.getFileName.toString){ _ => }(fileSheet))
      }

  lazy val thePaths: Seq[Path] = (dirs ++ files).filter(Visible)
  import unstyled.dynamic.SeqViewer
  lazy val theSeq = for { path <- thePaths } yield {
    import FileAttributes._
    val attrs = readAttributes(path, classOf[PosixFileAttributes], LinkOption.NOFOLLOW_LINKS)
    val name = path.getFileName.toString.take(30)
    val legible = legibleAttributes(attrs)
    import legible._
    f"$name%-30s $dmode%-10s $owner%s $size%n"
  }
  lazy val view = new SeqViewer(80, 25, fileSheet.buttonFont, fileSheet.buttonForegroundBrush, fileSheet.buttonBackgroundBrush, Brushes.red)(theSeq)
  lazy val GUI: Glyph = NaturalSize.Row()(
        Col()((dirButtons ++ fileButtons).prepended(styled.Label(folder.path.toString)(dirSheet))),
        (view)
  )

}

object Explore extends Application {
  implicit val dirSheet: StyleSheet = StyleSheet(buttonFontSize = 18, labelFontSize = 18,  labelForegroundBrush= Brushes.black)
  implicit val fileSheet: StyleSheet = StyleSheet(buttonFontSize = 18, labelFontSize = 18, buttonFontStyle=ITALIC, labelForegroundBrush= Brushes.black)

  val root = new Folder(fileSystem.getPath("/", "Users", "sufrin"))

  def GUI: Glyph = new Explorer(root)(dirSheet, fileSheet).GUI

  def title: String = "Explore"
}

object TestFiles extends Application {
  import styled.TextButton
  import NaturalSize._
  implicit val sheet: StyleSheet = StyleSheet()
  val byModification = new Ordering[Path] { def compare(o1: Path, o2: Path): Int = (o1.toFile.lastModified-o2.toFile.lastModified).sign.toInt}
  lazy val fileSystem = FileSystems.getDefault
  val home = new Folder(fileSystem.getPath("/", "Users", "sufrin"))

  def GUI: Glyph = Col(
      TextButton("/Users/sufrin"){ _ =>
         println(home.path)
         home.withValidCaches {
           val (dirs, notDirs) = home.splitDirs.value
           for {path <- dirs} println(path)
           for {path <- notDirs} println(path)
         }
        println("----")
      },
      TextButton("/Users/sufrin (dirs)"){ _ =>
        println(home.path)
        home.withValidCaches {
          for {path <- home.dirs.value} println(path)
        }
        println("----")
      },
      TextButton("/Users/sufrin (dirs) -T"){ _ =>
        println(home.path)
        home.withValidCaches {
          for {path <- home.dirs.value.sorted(byModification)} println(path)
        }
        println("----")
      },
      TextButton("/Users/sufrin (non dirs)"){ _ =>
        println(home.path)
        home.withValidCaches {
          for {path <- home.notDirs.value} println(path)
        }
        println("----")
      },
      TextButton("/Users/sufrin (non dirs) -T"){ _ =>
        println(home.path)
        home.withValidCaches {
          for {path <- home.notDirs.value.sorted(byModification)} println(path)
        }
        println("----")
      },
      TextButton("/Users/sufrin (attrs)"){ _ =>
        println(home.path)
        home.withValidCaches {
          import FileAttributes.legibleAttributes
          for {(path, attrs) <- home.attributes(home.dirs.value)} println(s"$path ${attrs.asString}")
          for {(path, attrs) <- home.attributes(home.notDirs.value)} println(s"$path ${attrs.asString}")
        }
        println("----")
      },
      TextButton("/Users/sufrin (map)"){ _ =>
        println(home.path)
        home.withValidCaches {
          import FileAttributes.legibleAttributes
          for { (path, attrs) <- home.attributeMap.value }
            println(s"$path ${attrs.asString}")
          }
        println("----")
      },
      TextButton("Filestores"){ _ =>
        println(f"${"Volume"}%-30s ${"Size"}%-7s ${"Used"}%7s / ${"Available"}%-7s " )
        for { store <- System.fileStores if (store.toString=="/" || !store.toString.startsWith("/System")) } {
          val useable: Long = store.getUsableSpace
          val total: Long   = store.getTotalSpace
          val unallocated: Long = store.getUnallocatedSpace
          val used: Long = total-unallocated
          val mb: Long = 1000*1000
          val gb: Long = 1000*mb
          println(f"${store.toString.replaceFirst("""[(][^)]+[)]""","")}%-30s ${total/gb}%-7d ${used/gb}%7d / ${unallocated/gb}%-7d  " )
        }
        println("----")
      },
      TextButton("[X]"){ _ =>
        home.invalidate()
      }


  )

  def title: String = "Files"

  override val dock = Dock(" Phy \nles", bg=Brushes.yellow)
}

