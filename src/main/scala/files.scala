package org.sufrin.glyph
package files

import java.nio.file._
import java.nio.file.attribute._
import java.util.Comparator
import scala.collection.mutable
import scala.jdk.CollectionConverters._


object System {
  lazy val fileStores: Iterable[FileStore] = FileSystems.getDefault.getFileStores.asScala
  lazy val rootDirs:   Iterable[Path] = FileSystems.getDefault.getRootDirectories.asScala
  lazy val supported:  mutable.Set[String] = FileSystems.getDefault.supportedFileAttributeViews.asScala
}

/**
 * A cache for a value
 * @param generate function to generate the value
 * @tparam T the type of the value
 */
class Cache[T]( generate: ()=>T ) {
  private var current: Option[T] = None
  /** Is the cache currently valid? */
  def isValid: Boolean = current.nonEmpty
  /** The currently cached value; regenerated if necessary. */
  def value: T = current match {
    case None =>
      val t = generate()
      current = Some(t)
      t
    case Some(t) => t
  }
  /** Invalidate the cached value: the next `value` will regenerate the cached value*/
  def invalidate(): Unit = current = None
}


object Cache {
  /**
   * A `Cache[T]` (re-)generated by `generate`
   */
  def apply[T](generate:  => T): Cache[T] = new Cache(() => generate)
}

/**
 *  Proxy for the directory/folder at `path`.
 */
class Folder(val path: Path) {
  import java.nio.file.Files.{list, readAttributes}
  private val byName = new Comparator[Path] { def compare(o1: Path, o2: Path): Int = o1.toString.compareToIgnoreCase(o2.toString) }

  lazy val sortedPaths: Cache[Seq[Path]] = Cache[Seq[Path]]{
      require (path.toFile.isDirectory, s"$path is not a directory")
      val stream = list(path).sorted(byName)
      stream.iterator().asScala.toSeq
  }

  lazy val dirs: Cache[Seq[Path]] = Cache {
    sortedPaths.value.filter(_.toFile.isDirectory)
  }

  lazy val notDirs: Cache[Seq[Path]] = Cache {
    sortedPaths.value.filterNot(_.toFile.isDirectory)
  }

  lazy val splitDirs: Cache[(Seq[Path], Seq[Path])] = {
   val paths = sortedPaths
   val dirs, nonDirs = new collection.mutable.ArrayBuffer[Path]
   for { path <- sortedPaths.value }
     (if (path.toFile.isDirectory) dirs else nonDirs).addOne(path)
    Cache(dirs.toSeq, nonDirs.toSeq)
  }

  def readPosixAttributes(path: Path): PosixFileAttributes = readAttributes(path, classOf[PosixFileAttributes], LinkOption.NOFOLLOW_LINKS)

  def attributes(paths: Seq[Path]): Seq[(Path, PosixFileAttributes)] = {
    paths.map { path => (path.getFileName, readPosixAttributes(path))}
  }

  lazy val prefixPaths: Seq[Path] = {
    val count = path.getNameCount
    for { i<-0 until count} yield path.getName(i)
  }

  /**
   * A mapping from the filenames in this folder to their posix attributes. This
   * mapping is kept up-to-date incrementally whenever `validate()` is invoked.
   */
  lazy val attributeMap: Cache[mutable.LinkedHashMap[Path,PosixFileAttributes]] = Cache {
    val attrs = attributes(sortedPaths.value)
    val map = new mutable.LinkedHashMap[Path,PosixFileAttributes]
    for (entry <- attrs) map.addOne(entry)
    map
  }

  /**
   * Invalidate all caches except the `attributeMap`.
   */
  def invalidate(): Unit = {
    for { cache <- List(splitDirs, dirs, notDirs, sortedPaths) } cache.invalidate()
  }

  def withValidCaches[T](expression: => T): Unit = {
    validate()
    expression
  }


  /**
   *  When anything happens to this directory we invalidate all the (rarely-used)
   *  sequence caches as a whole; and we update the `attributeMap` incrementally.
   */
  private val watching = java.nio.file.FileSystems.getDefault.newWatchService()
  locally {
    import StandardWatchEventKinds._
    path.register(watching,ENTRY_CREATE,ENTRY_DELETE,ENTRY_MODIFY,OVERFLOW)
  }

  private def validate(): Unit = {
    val watchKey = watching.poll
    if (watchKey ne null) {
      var changes, overflow = false
      for { event <- watchKey.pollEvents.asScala } {
        import StandardWatchEventKinds._
        val changedKey = event.context.asInstanceOf[Path]
        val changedPath = path.resolve(changedKey)
        println(s"${event.kind} ${event.context} $changedPath")
        try {
          event.kind match {
            case ENTRY_CREATE =>
              attributeMap.value.update(changedKey, readPosixAttributes(changedPath))
            case ENTRY_MODIFY =>
              attributeMap.value.update(changedKey, readPosixAttributes(changedPath))
            case ENTRY_DELETE =>
              attributeMap.value.remove(changedKey)
            case OVERFLOW =>
              overflow = true
          }
          changes=true
        } catch {
          case exn: NoSuchFileException =>
          // a deletion has followed a create or a modify since the last
          // time validate was invoked so there are no attributes to read
          // from the filestore when we try to act on the preceding create/modify
          // events.
        }
      }
      watchKey.reset()
      if (changes) {
        invalidate()
        if (overflow) attributeMap.invalidate()
      }
    }
  }

}

object FileAttributes {
  implicit class legibleAttributes(attrs: PosixFileAttributes) {
    def lastModifiedTime: FileTime = attrs.lastModifiedTime()
    def lastAccessTime: FileTime = attrs.lastAccessTime()
    def creationTime: FileTime = attrs.creationTime()
    def owner: UserPrincipal = attrs.owner()
    def group: GroupPrincipal = attrs.group()
    def permissions: collection.mutable.Set[PosixFilePermission] = attrs.permissions().asScala
    def mode: String = PosixFilePermissions.toString(attrs.permissions)
    def isDirectory: Boolean = attrs.isDirectory
    def isSymbolicLink: Boolean = attrs.isSymbolicLink
    def size: Long = attrs.size
    lazy private val d = if (isDirectory) "d" else "-"
    lazy private val s = if (isSymbolicLink) "@" else " "
    def dmode: String = s"$d$mode$s"
    def asString: String = s"$dmode $owner.$group $size $creationTime $lastModifiedTime $lastAccessTime"
  }

}

